<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>De Wraak van de Sint - Jumpscare Edition</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Creepster&family=Nosifer&family=Roboto:wght@400;700&family=Caveat:wght@700&display=swap');

        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            color: #a00;
            font-family: 'Roboto', sans-serif;
            overflow: hidden;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* CRT/VHS Effects */
        canvas {
            image-rendering: pixelated; 
            width: 100%;
            height: 100%;
            filter: contrast(1.2) brightness(1.1) sepia(0.2); 
        }

        .scanlines {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2));
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 50;
        }

        .noise {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMDAiIGhlaWdodD0iMjAwIj48ZmlsdGVyIGlkPSJub2lzZSI+PGZlVHVyYnVsZW5jZSB0eXBlPSJmcmFjdGFsTm9pc2UiIGJhc2VGcmVxdWVuY3k9IjAuNjUiIG51bU9jdGF2ZXM9IjMiIHN0aXRjaFRpbGVzPSJzdGl0Y2giLz48L2ZpbHRlcj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWx0ZXI9InVybCgjbm9pc2UpIiBvcGFjaXR5PSIwLjA4Ii8+PC9zdmc+');
            pointer-events: none;
            z-index: 51;
            opacity: 0.08;
            animation: noiseAnim 0.2s infinite;
            transition: opacity 0.1s;
        }

        @keyframes noiseAnim {
            0% { transform: translate(0,0); }
            100% { transform: translate(10px,10px); }
        }

        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
            z-index: 60;
        }

        #lore-text {
            position: absolute;
            bottom: 20%;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Caveat', cursive;
            font-size: 2rem;
            color: #ddd;
            text-shadow: 2px 2px 4px #000;
            text-align: center;
            opacity: 0;
            transition: opacity 0.5s;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #444;
            max-width: 80%;
            pointer-events: none;
        }

        #score-display {
            color: #888;
            font-family: 'Creepster', cursive;
            font-size: 2rem;
            opacity: 0.7;
            text-shadow: 2px 2px 0 #000;
        }

        #message-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #050000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            pointer-events: auto;
            text-align: center;
        }
        
        #jumpscare-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 200;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.05s;
        }
        
        #jumpscare-img { width: 100%; height: 100%; object-fit: cover; }

        h1 {
            font-family: 'Nosifer', cursive;
            font-size: 4rem;
            color: #b00;
            margin-bottom: 20px;
            text-shadow: 4px 4px 0px #000;
        }

        p {
            color: #666;
            font-size: 1.1rem;
            max-width: 500px;
            margin: 0 auto 30px auto;
            line-height: 1.6;
            font-family: monospace;
        }

        button {
            background: #100;
            color: #800;
            border: 1px solid #400;
            padding: 20px 40px;
            font-size: 1.5rem;
            font-family: 'Creepster', cursive;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        button:hover {
            background: #300;
            color: #f00;
            box-shadow: 0 0 20px #500;
        }

        .hidden { display: none !important; }

        /* Flashlight Vignette */
        #vignette {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            /* Will be updated via JS for proximity effect */
            background: radial-gradient(circle at center, rgba(0,0,0,0) 20%, rgba(0,0,0,0.5) 40%, rgba(0,0,0,0.95) 70%, black 100%);
            pointer-events: none;
            z-index: 55;
            mix-blend-mode: multiply;
            transition: box-shadow 0.2s;
        }

        /* Danger Overlay (Blood edges) */
        #danger-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            box-shadow: inset 0 0 0px #f00;
            pointer-events: none;
            z-index: 56;
            mix-blend-mode: overlay;
            transition: box-shadow 0.2s;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <div class="scanlines"></div>
    <div class="noise"></div>
    <div id="vignette"></div>
    <div id="danger-overlay"></div>
    <div id="jumpscare-overlay"></div>
    
    <div id="ui-layer">
        <div>
            <div id="score-display">VIND DE DEUR</div>
        </div>
        <div id="lore-text"></div>
        <div id="controls-hint" style="color:#444; font-family: monospace;">WASD / Shift</div>
    </div>

    <div id="message-overlay">
        <h1>VERLOREN ZIELEN</h1>
        <p>Je hebt alleen een zaklamp.</p>
        <p>Kijk ze niet aan. Ze haten het als je kijkt.</p>
        <button id="start-btn">BETREDEN</button>
    </div>
</div>

<script>
    // --- Configuration ---
    const MAP_WIDTH = 60; // Bigger map
    const MAP_HEIGHT = 50;
    const SCREEN_WIDTH = 320; 
    const SCREEN_HEIGHT = 180;
    
    const MOVE_SPEED = 0.07;
    const RUN_SPEED = 0.12;
    const ROT_SPEED = 0.05;
    
    // --- Audio ---
    let audioCtx;
    let nextAmbientSoundTime = 0;
    
    // --- Game State ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d', { alpha: false }); 
    const msgOverlay = document.getElementById('message-overlay');
    const jumpscareOverlay = document.getElementById('jumpscare-overlay');
    const startBtn = document.getElementById('start-btn');
    const loreTextEl = document.getElementById('lore-text');
    const dangerOverlay = document.getElementById('danger-overlay');
    const noiseOverlay = document.querySelector('.noise');

    let gameRunning = false;
    let keys = {};
    let sintProximity = 0;
    let zBuffer = []; 
    let startTime = 0; 
    let frameCount = 0;
    
    let hallucinations = [];
    let lastHallucinationCheck = 0;

    let mapLayout = [];

    // Player
    let posX = 0, posY = 0; 
    let dirX = -1, dirY = 0; 
    let planeX = 0, planeY = 0.66; 

    // Entities
    let sint = { x: 0, y: 0, active: true, lastX: 0, lastY: 0 };
    let sprites = []; 
    
    // Lore Database
    const loreMessages = [
        "Het bloed op de muren... het wijst naar de uitgang.",
        "Hij eet geen kinderen. Hij eet hun dromen.",
        "Ik zag hem door de muur lopen. Dit is geen normaal gebouw.",
        "Kijk hem niet in de ogen. Hij ruikt je angst.",
        "5 December is de dag van het oordeel.",
        "Volg de pijlen als je wilt leven.",
        "Ze stormen op je af als je te lang staart."
    ];

    // Textures
    const texWidth = 64;
    const texHeight = 64;
    let textures = {}; 

    // --- Texture Generation ---
    function generateTextures() {
        function createTexture(color1, color2, type, variant) {
            const c = document.createElement('canvas');
            c.width = texWidth; c.height = texHeight;
            const cx = c.getContext('2d');
            
            // Base Color
            cx.fillStyle = color1; 
            cx.fillRect(0,0,64,64);
            
            // Gritty noise
            for(let i=0; i<300; i++) {
                cx.fillStyle = Math.random()>0.5 ? '#000' : '#222';
                cx.globalAlpha = 0.2;
                cx.fillRect(Math.random()*64, Math.random()*64, 2, 2);
            }
            cx.globalAlpha = 1.0;

            if (type.includes('wall')) {
                cx.fillStyle = color2;
                for(let i=0; i<6; i++) cx.fillRect(i*10 + Math.random()*4, 0, 4, 64);
                
                if (type === 'wall_bloody') {
                    cx.fillStyle = '#600'; 
                    cx.font = 'bold 16px Courier';
                    
                    // Specific Arrow variants for navigation
                    if (variant === 'arrow_left') {
                        cx.beginPath(); cx.moveTo(50, 32); cx.lineTo(20, 32); cx.lineTo(30, 20); cx.moveTo(20, 32); cx.lineTo(30, 44);
                        cx.lineWidth = 4; cx.strokeStyle = '#800'; cx.stroke();
                    } else if (variant === 'arrow_right') {
                         cx.beginPath(); cx.moveTo(14, 32); cx.lineTo(44, 32); cx.lineTo(34, 20); cx.moveTo(44, 32); cx.lineTo(34, 44);
                        cx.lineWidth = 4; cx.strokeStyle = '#800'; cx.stroke();
                    } else {
                         // Random scary text
                         cx.save();
                         cx.translate(32, 32);
                         cx.rotate((Math.random()-0.5)*0.5);
                         cx.fillStyle = '#600';
                         cx.fillText("†", -5, 5);
                         cx.fillRect(-10, 10, 2, 20);
                         cx.restore();
                    }
                }
            } 
            return c;
        }

        function createSprite(type) {
            const c = document.createElement('canvas');
            c.width = 128; c.height = 128;
            const cx = c.getContext('2d');
            
            if (type === 'paper') {
                cx.fillStyle = '#ffc';
                cx.fillRect(44, 100, 40, 28); 
                cx.fillStyle = '#000';
                for(let i=0; i<4; i++) cx.fillRect(48, 105 + i*5, 30, 2); 
                cx.shadowBlur = 15; cx.shadowColor = '#ffc';
                cx.strokeStyle = '#ffc'; cx.strokeRect(44,100,40,28);
                cx.shadowBlur = 0;
            } else if (type === 'door') {
                cx.fillStyle = '#222'; cx.fillRect(30, 0, 68, 128);
                cx.strokeStyle = '#632'; cx.lineWidth = 4; cx.strokeRect(30, 0, 68, 128);
                cx.fillStyle = '#a00'; cx.font = '40px serif'; cx.fillText("Ω", 50, 80);
            } else if (type === 'sint') {
                cx.fillStyle = '#800'; 
                cx.beginPath(); cx.moveTo(40, 128); cx.lineTo(64, 20); cx.lineTo(88, 128); cx.fill();
                cx.fillStyle = '#600';
                cx.beginPath(); cx.moveTo(40, 128); cx.lineTo(30, 50); cx.lineTo(64, 20); cx.lineTo(98, 50); cx.lineTo(88, 128); cx.fill();
                cx.strokeStyle = '#d90'; cx.lineWidth = 4;
                cx.beginPath(); cx.moveTo(90, 128); cx.lineTo(100, 10); cx.stroke();
                cx.beginPath(); cx.arc(100, 10, 5, 0, Math.PI*2); cx.stroke();
                cx.fillStyle = '#eee'; 
                cx.beginPath(); cx.arc(64, 30, 12, 0, Math.PI*2); cx.fill();
                cx.fillStyle = '#a00';
                cx.beginPath(); cx.moveTo(50, 25); cx.lineTo(64, -10); cx.lineTo(78, 25); cx.fill();
                cx.strokeStyle = '#fa0'; cx.lineWidth=2;
                cx.beginPath(); cx.moveTo(64, -10); cx.lineTo(64, 25); cx.stroke();
                cx.fillStyle = '#f00'; 
                cx.shadowBlur = 10; cx.shadowColor = 'red';
                cx.beginPath(); cx.arc(60, 30, 2, 0, Math.PI*2); cx.fill();
                cx.beginPath(); cx.arc(68, 30, 2, 0, Math.PI*2); cx.fill();
                cx.shadowBlur = 0;
                cx.fillStyle = '#fff';
                cx.beginPath(); cx.moveTo(52, 35); cx.lineTo(64, 60); cx.lineTo(76, 35); cx.fill();
            } else if (type === 'piet') {
                cx.fillStyle = '#111'; 
                cx.beginPath(); cx.ellipse(64, 80, 20, 40, 0, 0, Math.PI*2); cx.fill();
                cx.beginPath(); cx.arc(64, 40, 18, 0, Math.PI*2); cx.fill();
                cx.strokeStyle = '#222'; cx.lineWidth = 1; cx.stroke();
                cx.strokeStyle = '#505'; cx.lineWidth=3; 
                cx.beginPath(); cx.moveTo(64, 25); cx.lineTo(90, 10); cx.stroke();
                cx.fillStyle = '#fff';
                cx.shadowBlur = 10; cx.shadowColor = '#fff';
                cx.beginPath(); cx.arc(58, 40, 3, 0, Math.PI*2); cx.fill();
                cx.beginPath(); cx.arc(70, 40, 3, 0, Math.PI*2); cx.fill();
                cx.shadowBlur = 0;
            }
            return c;
        }

        function createJumpscare() {
            const c = document.createElement('canvas');
            c.width = 400; c.height = 400;
            const cx = c.getContext('2d');
            cx.fillStyle = '#000'; cx.fillRect(0,0,400,400);
            for(let i=0; i<1000; i++) {
                cx.fillStyle = Math.random()>0.8?'#f00':'#200';
                cx.fillRect(Math.random()*400, Math.random()*400, 5, 5);
            }
            cx.fillStyle = '#ccc';
            cx.beginPath(); cx.arc(200, 180, 120, 0, Math.PI*2); cx.fill();
            cx.fillRect(140, 180, 120, 150);
            cx.fillStyle = '#000';
            cx.beginPath(); cx.arc(150, 160, 30, 0, Math.PI*2); cx.fill();
            cx.beginPath(); cx.arc(250, 160, 30, 0, Math.PI*2); cx.fill();
            cx.beginPath(); cx.ellipse(200, 320, 60, 100, 0, 0, Math.PI*2); cx.fill();
            cx.fillStyle = '#ff9';
            for(let i=0; i<10; i++) {
                cx.fillRect(150 + i*10, 250, 5, 20); 
                cx.fillRect(150 + i*10, 380, 5, 20); 
            }
            return c;
        }

        textures.wall = createTexture('#444', '#333', 'wall', 0); 
        // 5, 6, 7 reserved for blood
        textures.wall_bloody_1 = createTexture('#444', '#333', 'wall_bloody', 'random');
        
        // 8 = Arrow Left, 9 = Arrow Right
        textures.wall_arrow_left = createTexture('#444', '#333', 'wall_bloody', 'arrow_left');
        textures.wall_arrow_right = createTexture('#444', '#333', 'wall_bloody', 'arrow_right');
        
        textures.door = createSprite('door');
        textures.paper = createSprite('paper');
        textures.sint = createSprite('sint');
        textures.piet = createSprite('piet');
        
        const jumpCanvas = createJumpscare();
        const jumpImg = document.createElement('img');
        jumpImg.src = jumpCanvas.toDataURL();
        jumpImg.id = "jumpscare-img";
        jumpscareOverlay.innerHTML = '';
        jumpscareOverlay.appendChild(jumpImg);
    }

    // --- Map Generation ---
    function generateMap() {
        let map = [];
        for(let y=0; y<MAP_HEIGHT; y++) {
            let row = [];
            for(let x=0; x<MAP_WIDTH; x++) row.push(1);
            map.push(row);
        }

        let stack = [];
        let startX = 1, startY = 1;
        map[startY][startX] = 0;
        stack.push({x: startX, y: startY});
        
        // Recursive Backtracker
        while(stack.length > 0) {
            let current = stack[stack.length - 1];
            let neighbors = [];
            let dirs = [{x: 0, y: -2}, {x: 0, y: 2}, {x: -2, y: 0}, {x: 2, y: 0}];
            for(let d of dirs) {
                let nx = current.x + d.x;
                let ny = current.y + d.y;
                if(nx > 0 && nx < MAP_WIDTH-1 && ny > 0 && ny < MAP_HEIGHT-1) {
                    if(map[ny][nx] === 1) neighbors.push({x: nx, y: ny, dx: d.x/2, dy: d.y/2});
                }
            }
            if(neighbors.length > 0) {
                let chosen = neighbors[Math.floor(Math.random() * neighbors.length)];
                map[current.y + chosen.dy][current.x + chosen.dx] = 0;
                map[chosen.y][chosen.x] = 0;
                stack.push({x: chosen.x, y: chosen.y});
            } else stack.pop();
        }
        
        // Add random loops (holes)
        for(let i=0; i<40; i++) {
            let rx = Math.floor(Math.random()*(MAP_WIDTH-2))+1;
            let ry = Math.floor(Math.random()*(MAP_HEIGHT-2))+1;
            if(map[ry][rx]===1) {
                // Check if it connects two corridors
                if((map[ry-1][rx]===0 && map[ry+1][rx]===0) || (map[ry][rx-1]===0 && map[ry][rx+1]===0)) map[ry][rx]=0;
            }
        }

        // --- POIs: Big Rooms ---
        for(let i=0; i<5; i++) {
             let rx = Math.floor(Math.random()*(MAP_WIDTH-6))+2;
             let ry = Math.floor(Math.random()*(MAP_HEIGHT-6))+2;
             // Clear a 3x3 or 4x4 area
             let size = Math.floor(Math.random()*2) + 3;
             for(let cy=0; cy<size; cy++) {
                 for(let cx=0; cx<size; cx++) {
                     if(ry+cy < MAP_HEIGHT-1 && rx+cx < MAP_WIDTH-1) {
                         map[ry+cy][rx+cx] = 0;
                     }
                 }
             }
        }

        posX = 1.5; posY = 1.5;

        // Place Exit Far Away
        let placedExit = false;
        let doorX = 0, doorY = 0;
        
        let attempts = 0;
        while(!placedExit && attempts < 1000) {
            attempts++;
            let rx = Math.floor(Math.random() * MAP_WIDTH);
            let ry = Math.floor(Math.random() * MAP_HEIGHT);
            if(map[ry][rx] === 0 && Math.hypot(rx - posX, ry - posY) > 40) {
                sprites.push({ x: rx+0.5, y: ry+0.5, type: 'door', active: true });
                placedExit = true;
                doorX = rx; doorY = ry;
            }
        }
        if(!placedExit) {
             doorX = MAP_WIDTH-2; doorY = MAP_HEIGHT-2;
             map[doorY][doorX] = 0;
             sprites.push({ x: doorX+0.5, y: doorY+0.5, type: 'door', active: true });
        }

        // --- Navigation Hints (Breadth-First Search) ---
        let distMap = [];
        for(let y=0; y<MAP_HEIGHT; y++) {
            let row = [];
            for(let x=0; x<MAP_WIDTH; x++) row.push(-1);
            distMap.push(row);
        }
        
        let q = [{x: doorX, y: doorY, dist: 0}];
        distMap[doorY][doorX] = 0;
        
        while(q.length > 0) {
            let curr = q.shift();
            let dirs = [{x:0,y:-1}, {x:0,y:1}, {x:-1,y:0}, {x:1,y:0}];
            for(let d of dirs) {
                let nx = curr.x + d.x;
                let ny = curr.y + d.y;
                if(nx >= 0 && nx < MAP_WIDTH && ny >= 0 && ny < MAP_HEIGHT) {
                    if(map[ny][nx] === 0 && distMap[ny][nx] === -1) {
                        distMap[ny][nx] = curr.dist + 1;
                        q.push({x: nx, y: ny, dist: curr.dist + 1});
                    }
                }
            }
        }

        for(let y=1; y<MAP_HEIGHT-1; y++) {
            for(let x=1; x<MAP_WIDTH-1; x++) {
                if(map[y][x] === 0 && distMap[y][x] > 5 && Math.random() < 0.04) {
                    let currentDist = distMap[y][x];
                    let bestDir = null;
                    
                    if (distMap[y-1][x] !== -1 && distMap[y-1][x] < currentDist) bestDir = 'N';
                    else if (distMap[y+1][x] !== -1 && distMap[y+1][x] < currentDist) bestDir = 'S';
                    else if (distMap[y][x-1] !== -1 && distMap[y][x-1] < currentDist) bestDir = 'W';
                    else if (distMap[y][x+1] !== -1 && distMap[y][x+1] < currentDist) bestDir = 'E';
                    
                    if(bestDir === 'W') { 
                         if(map[y-1][x]===1) map[y-1][x] = 8; 
                         else if(map[y+1][x]===1) map[y+1][x] = 9; 
                    } else if (bestDir === 'E') { 
                         if(map[y-1][x]===1) map[y-1][x] = 9; 
                         else if(map[y+1][x]===1) map[y+1][x] = 8; 
                    } else if (bestDir === 'N') { 
                        if(map[y][x+1]===1) map[y][x+1] = 8; 
                        else if(map[y][x-1]===1) map[y][x-1] = 9; 
                    } else if (bestDir === 'S') { 
                        if(map[y][x+1]===1) map[y][x+1] = 9; 
                        else if(map[y][x-1]===1) map[y][x-1] = 8; 
                    }
                }
            }
        }
        
        for(let i=0; i<30; i++) {
             let rx = Math.floor(Math.random() * (MAP_WIDTH-2))+1;
             let ry = Math.floor(Math.random() * (MAP_HEIGHT-2))+1;
             if(map[ry][rx] === 1) map[ry][rx] = 5;
        }

        for(let i=0; i<10; i++) {
            let rx = Math.floor(Math.random() * MAP_WIDTH);
            let ry = Math.floor(Math.random() * MAP_HEIGHT);
            if(map[ry][rx] === 0) {
                let msg = loreMessages[Math.floor(Math.random() * loreMessages.length)];
                sprites.push({ x: rx+0.5, y: ry+0.5, type: 'paper', active: true, msg: msg });
            }
        }

        let placedSint = false;
        while(!placedSint) {
            let rx = Math.floor(Math.random() * MAP_WIDTH);
            let ry = Math.floor(Math.random() * MAP_HEIGHT);
            if(map[ry][rx] === 0 && Math.hypot(rx - posX, ry - posY) > 15) {
                sint = { x: rx+0.5, y: ry+0.5, type: 'sint', active: true, lastX: rx, lastY: ry };
                sprites.push(sint);
                placedSint = true;
            }
        }
        return map;
    }

    // --- Init ---
    function initGame() {
        canvas.width = SCREEN_WIDTH;
        canvas.height = SCREEN_HEIGHT;
        generateTextures();
        sprites = [];
        hallucinations = [];
        mapLayout = generateMap();
        
        dirX = -1; dirY = 0;
        planeX = 0; planeY = 0.66;
        
        gameRunning = true;
        startTime = Date.now();
        nextAmbientSoundTime = Date.now() + 2000;
        
        msgOverlay.classList.add('hidden');
        jumpscareOverlay.style.opacity = 0;
        noiseOverlay.style.opacity = 0.08;
        initAudio();
        requestAnimationFrame(gameLoop);
    }

    window.addEventListener('keydown', (e) => { keys[e.key.toLowerCase()] = true; if(e.shiftKey) keys['shift'] = true; });
    window.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; if(!e.shiftKey) keys['shift'] = false; });
    startBtn.addEventListener('click', () => { initGame(); });

    // --- Update ---
    function updateGame() {
        let now = Date.now();
        frameCount++;

        if (keys['d'] || keys['arrowright']) {
            let oldDirX = dirX;
            dirX = dirX * Math.cos(-ROT_SPEED) - dirY * Math.sin(-ROT_SPEED);
            dirY = oldDirX * Math.sin(-ROT_SPEED) + dirY * Math.cos(-ROT_SPEED);
            let oldPlaneX = planeX;
            planeX = planeX * Math.cos(-ROT_SPEED) - planeY * Math.sin(-ROT_SPEED);
            planeY = oldPlaneX * Math.sin(-ROT_SPEED) + planeY * Math.cos(-ROT_SPEED);
        }
        if (keys['a'] || keys['arrowleft']) {
            let oldDirX = dirX;
            dirX = dirX * Math.cos(ROT_SPEED) - dirY * Math.sin(ROT_SPEED);
            dirY = oldDirX * Math.sin(ROT_SPEED) + dirY * Math.cos(ROT_SPEED);
            let oldPlaneX = planeX;
            planeX = planeX * Math.cos(ROT_SPEED) - planeY * Math.sin(ROT_SPEED);
            planeY = oldPlaneX * Math.sin(ROT_SPEED) + planeY * Math.cos(ROT_SPEED);
        }

        let currentSpeed = keys['shift'] ? RUN_SPEED : MOVE_SPEED;
        function isBlocking(val) { return val === 1 || (val >= 5 && val <= 9); } 

        if (keys['w'] || keys['arrowup']) {
            if(!isBlocking(mapLayout[Math.floor(posY)][Math.floor(posX + dirX * currentSpeed * 2)])) posX += dirX * currentSpeed;
            if(!isBlocking(mapLayout[Math.floor(posY + dirY * currentSpeed * 2)][Math.floor(posX)])) posY += dirY * currentSpeed;
        }
        if (keys['s'] || keys['arrowdown']) {
            if(!isBlocking(mapLayout[Math.floor(posY)][Math.floor(posX - dirX * currentSpeed * 2)])) posX -= dirX * currentSpeed;
            if(!isBlocking(mapLayout[Math.floor(posY - dirY * currentSpeed * 2)][Math.floor(posX)])) posY -= dirY * currentSpeed;
        }

        // Lore
        let nearbyPaper = null;
        sprites.forEach(s => {
            if(s.type === 'paper') {
                let d = Math.sqrt((posX - s.x)**2 + (posY - s.y)**2);
                if(d < 1.0) nearbyPaper = s.msg;
            }
        });
        if(nearbyPaper) { loreTextEl.innerText = nearbyPaper; loreTextEl.style.opacity = 1; } 
        else { loreTextEl.style.opacity = 0; }

        // --- NEW Hallucination Logic (Rush) ---
        if (now - lastHallucinationCheck > 300) { 
            lastHallucinationCheck = now;
            // Spawn chance
            if (hallucinations.length < 5 && Math.random() < 0.6) {
                let spawnDist = 4 + Math.random() * 6;
                let angle = Math.atan2(dirY, dirX) + (Math.random() - 0.5) * 1.5;
                let hX = posX + Math.cos(angle) * spawnDist;
                let hY = posY + Math.sin(angle) * spawnDist;
                if (hX > 1 && hX < MAP_WIDTH-1 && hY > 1 && hY < MAP_HEIGHT-1) {
                    if (mapLayout[Math.floor(hY)][Math.floor(hX)] === 0) {
                        let piet = { 
                            x: hX, y: hY, 
                            type: 'piet', 
                            active: true, 
                            spawnTime: now,
                            rushing: false,
                            rushChecked: false
                        };
                        hallucinations.push(piet);
                        sprites.push(piet);
                    }
                }
            }
        }
        
        for(let i = hallucinations.length - 1; i >= 0; i--) {
            let p = hallucinations[i];
            let pdx = posX - p.x;
            let pdy = posY - p.y;
            let distToPlayer = Math.sqrt(pdx*pdx + pdy*pdy);

            // --- Rush Logic ---
            // Calculate if player is looking at Piet
            let toPietX = p.x - posX;
            let toPietY = p.y - posY;
            let toPietLen = Math.hypot(toPietX, toPietY);
            toPietX /= toPietLen; toPietY /= toPietLen;
            let dot = dirX * toPietX + dirY * toPietY;
            
            // If staring at it (dot > 0.65)
            if (dot > 0.65 && !p.rushing) {
                if(Math.random() < 0.05) { // Chance per frame to trigger rush
                    p.rushing = true;
                    playAmbientSound('rush_scream');
                }
            }

            if(p.rushing) {
                // Move very fast towards player
                let rushSpeed = 0.25;
                p.x += (pdx / distToPlayer) * rushSpeed;
                p.y += (pdy / distToPlayer) * rushSpeed;
                
                // Impact
                if(distToPlayer < 0.8) {
                    p.active = false;
                    hallucinations.splice(i, 1);
                    playAmbientSound('jumpscare_minor');
                    let spriteIndex = sprites.indexOf(p);
                    if (spriteIndex > -1) sprites.splice(spriteIndex, 1);
                    // Glitch effect
                    noiseOverlay.style.opacity = 0.9;
                    setTimeout(() => { noiseOverlay.style.opacity = 0.08; }, 200);
                    continue; 
                }
            } else {
                // Normal vanish logic
                if (distToPlayer < 2.5 || (now - p.spawnTime > 5000)) {
                    p.active = false; 
                    hallucinations.splice(i, 1);
                    playAmbientSound('vanish');
                    let spriteIndex = sprites.indexOf(p);
                    if (spriteIndex > -1) sprites.splice(spriteIndex, 1);
                }
            }
        }

        // Sint Logic
        let timeAlive = (now - startTime) / 1000;
        let sintSpeed = 0.045 + (timeAlive * 0.0006);
        if(sintSpeed > 0.11) sintSpeed = 0.11;

        let dx = posX - sint.x;
        let dy = posY - sint.y;
        let dist = Math.sqrt(dx*dx + dy*dy);
        
        if (frameCount % 120 === 0) {
            let stuck = Math.hypot(sint.x - sint.lastX, sint.y - sint.lastY) < 0.1;
            let tooFar = dist > 30; 
            if (stuck || tooFar) {
                 for(let i=0; i<10; i++) {
                     let angle = Math.atan2(dirY, dirX) + Math.PI + (Math.random()-0.5); 
                     let d = 8 + Math.random() * 6;
                     let tx = posX + Math.cos(angle) * d;
                     let ty = posY + Math.sin(angle) * d;
                     if(tx > 1 && tx < MAP_WIDTH-1 && ty > 1 && ty < MAP_HEIGHT-1) {
                         if(mapLayout[Math.floor(ty)][Math.floor(tx)] === 0) {
                             sint.x = tx + 0.5;
                             sint.y = ty + 0.5;
                             playAmbientSound('vanish'); 
                             break;
                         }
                     }
                 }
            }
            sint.lastX = sint.x;
            sint.lastY = sint.y;
        }

        if (dist > 0.5) {
            let sx = dx / dist * sintSpeed;
            let sy = dy / dist * sintSpeed;
            if (!isBlocking(mapLayout[Math.floor(sint.y)][Math.floor(sint.x + sx * 1.5)])) sint.x += sx;
            if (!isBlocking(mapLayout[Math.floor(sint.y + sy * 1.5)][Math.floor(sint.x)])) sint.y += sy;
        }

        sintProximity = Math.max(0, 1 - (dist / 12)); 
        
        let dangerAlpha = 0;
        if (sintProximity > 0.3) dangerAlpha = (sintProximity - 0.3) * 1.5; 
        if (dangerAlpha > 0.8) dangerAlpha = 0.8;
        dangerOverlay.style.boxShadow = `inset 0 0 ${dangerAlpha * 100}px #f00`;
        
        // Only modulate opacity if NOT currently glitched by jumpscare
        if(noiseOverlay.style.opacity < 0.8) {
             noiseOverlay.style.opacity = 0.08 + (sintProximity * 0.3);
        }

        updateSound(now);

        if (dist < 0.8) endGame(false); // Hitbox
        sprites.forEach(s => {
            if (!s.active || s.type !== 'door') return;
            let d = Math.sqrt((posX - s.x)**2 + (posY - s.y)**2);
            if (d < 0.6) endGame(true);
        });
    }

    // --- Audio ---
    function initAudio() {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if(audioCtx.state === 'suspended') audioCtx.resume();
    }

    function updateSound(now) {
        if(!audioCtx) return;
        if (now > nextAmbientSoundTime) {
            playAmbientSound('random');
            nextAmbientSoundTime = now + 3000 + Math.random() * 5000;
        }
    }

    function playAmbientSound(type) {
        if(!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        
        if (type === 'rush_scream') {
            // Rising screech
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(400, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(1200, audioCtx.currentTime + 0.3);
            gain.gain.setValueAtTime(0.0, audioCtx.currentTime);
            gain.gain.linearRampToValueAtTime(0.3, audioCtx.currentTime + 0.1);
            gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.3);
        } else if (type === 'jumpscare_minor') {
            // Burst noise
            const bufferSize = audioCtx.sampleRate * 0.2;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;
            const noiseGain = audioCtx.createGain();
            noise.connect(noiseGain);
            noiseGain.connect(audioCtx.destination);
            noiseGain.gain.setValueAtTime(0.5, audioCtx.currentTime);
            noiseGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
            noise.start();
        } else if (type === 'vanish') {
            const bufferSize = audioCtx.sampleRate * 0.5;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;
            const noiseGain = audioCtx.createGain();
            noise.connect(noiseGain);
            noiseGain.connect(audioCtx.destination);
            noiseGain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            noiseGain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);
            noise.start();
        } else if (Math.random() < 0.3) {
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(200, audioCtx.currentTime);
            osc.frequency.linearRampToValueAtTime(150, audioCtx.currentTime + 1);
            gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
            gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 1);
            osc.start();
            osc.stop(audioCtx.currentTime + 1);
        } else {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(50, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(10, audioCtx.currentTime + 1);
            gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
            gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 1);
            osc.start();
            osc.stop(audioCtx.currentTime + 1);
        }
    }

    function playScream() {
        if(!audioCtx) return;
        const bufferSize = audioCtx.sampleRate * 1.0;
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
        const noise = audioCtx.createBufferSource();
        noise.buffer = buffer;
        const gain = audioCtx.createGain();
        const filter = audioCtx.createBiquadFilter();
        filter.type = 'highpass';
        filter.frequency.value = 1000;
        noise.connect(filter);
        filter.connect(gain);
        gain.connect(audioCtx.destination);
        gain.gain.setValueAtTime(0.8, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 1.0);
        noise.start();
    }

    // --- Render ---
    function draw() {
        ctx.fillStyle = '#050505'; ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT / 2);
        ctx.fillStyle = '#111'; ctx.fillRect(0, SCREEN_HEIGHT / 2, SCREEN_WIDTH, SCREEN_HEIGHT / 2);

        let breathe = Math.sin(frameCount * 0.05) * 0.05;
        zBuffer = []; 

        for (let x = 0; x < SCREEN_WIDTH; x++) {
            let cameraX = 2 * x / SCREEN_WIDTH - 1;
            let rayDirX = dirX + planeX * cameraX;
            let rayDirY = dirY + planeY * cameraX;

            let mapX = Math.floor(posX);
            let mapY = Math.floor(posY);
            let sideDistX, sideDistY, perpWallDist;
            let stepX, stepY, side, wallType = 1;
            let deltaDistX = Math.abs(1 / rayDirX);
            let deltaDistY = Math.abs(1 / rayDirY);
            let hit = 0;

            if (rayDirX < 0) { stepX = -1; sideDistX = (posX - mapX) * deltaDistX; }
            else { stepX = 1; sideDistX = (mapX + 1.0 - posX) * deltaDistX; }
            if (rayDirY < 0) { stepY = -1; sideDistY = (posY - mapY) * deltaDistY; }
            else { stepY = 1; sideDistY = (mapY + 1.0 - posY) * deltaDistY; }

            while (hit === 0) {
                if (sideDistX < sideDistY) { sideDistX += deltaDistX; mapX += stepX; side = 0; }
                else { sideDistY += deltaDistY; mapY += stepY; side = 1; }
                let tile = mapLayout[mapY][mapX];
                if (tile === 1 || (tile >= 5 && tile <= 9)) { hit = 1; wallType = tile; }
            }

            if (side === 0) perpWallDist = (mapX - posX + (1 - stepX) / 2) / rayDirX;
            else            perpWallDist = (mapY - posY + (1 - stepY) / 2) / rayDirY;

            zBuffer[x] = perpWallDist; 

            let lineHeight = Math.floor(SCREEN_HEIGHT / perpWallDist);
            lineHeight *= (1 + breathe * (perpWallDist < 5 ? 1 : 0));
            
            let drawStart = -lineHeight / 2 + SCREEN_HEIGHT / 2;
            let drawEnd = lineHeight / 2 + SCREEN_HEIGHT / 2;

            let wallX; 
            if (side == 0) wallX = posY + perpWallDist * rayDirY;
            else           wallX = posX + perpWallDist * rayDirX;
            wallX -= Math.floor(wallX);
            let texX = Math.floor(wallX * texWidth);
            if(side == 0 && rayDirX > 0) texX = texWidth - texX - 1;
            if(side == 1 && rayDirY < 0) texX = texWidth - texX - 1;

            let tex = textures.wall;
            if(wallType === 5) tex = textures.wall_bloody_1;
            if(wallType === 8) tex = textures.wall_arrow_left;
            if(wallType === 9) tex = textures.wall_arrow_right;

            ctx.drawImage(tex, texX, 0, 1, texHeight, x, drawStart, 1, drawEnd - drawStart);
            
            let lightIntensity = 1.0 / (perpWallDist * 0.3); 
            if (lightIntensity > 1) lightIntensity = 1;
            let screenDist = Math.abs(x - SCREEN_WIDTH / 2) / (SCREEN_WIDTH / 2);
            let beam = 1.0 - Math.pow(screenDist, 2); 
            lightIntensity *= beam;
            if(perpWallDist > 8) lightIntensity *= 0.5;
            if (side === 1) lightIntensity *= 0.7;

            ctx.fillStyle = `rgba(0,0,0,${1 - lightIntensity})`;
            ctx.fillRect(x, drawStart, 1, drawEnd - drawStart);
        }

        sprites.forEach(s => {
            s.dist = ((posX - s.x) ** 2 + (posY - s.y) ** 2);
        });
        sprites.sort((a, b) => b.dist - a.dist);

        for (let i = 0; i < sprites.length; i++) {
            if(!sprites[i].active) continue;
            let sprite = sprites[i];
            let spriteX = sprite.x - posX;
            let spriteY = sprite.y - posY;

            let invDet = 1.0 / (planeX * dirY - dirX * planeY);
            let transformX = invDet * (dirY * spriteX - dirX * spriteY);
            let transformY = invDet * (-planeY * spriteX + planeX * spriteY); 
            let spriteScreenX = Math.floor((SCREEN_WIDTH / 2) * (1 + transformX / transformY));
            let spriteHeight = Math.abs(Math.floor(SCREEN_HEIGHT / transformY));
            
            let animOffset = 0;
            if (sprite.type === 'piet') animOffset = Math.sin(frameCount * 0.05) * 10;
            if (sprite.type === 'paper') animOffset = Math.sin(frameCount * 0.1) * 5 + 60; 

            let drawStartY = -spriteHeight / 2 + SCREEN_HEIGHT / 2 + animOffset / transformY;
            let drawEndY = spriteHeight / 2 + SCREEN_HEIGHT / 2 + animOffset / transformY;
            let spriteWidth = Math.abs(Math.floor(SCREEN_HEIGHT / transformY));
            let drawStartX = -spriteWidth / 2 + spriteScreenX;
            let drawEndX = spriteWidth / 2 + spriteScreenX;

            let tex;
            if (sprite.type === 'door') tex = textures.door;
            else if (sprite.type === 'sint') tex = textures.sint;
            else if (sprite.type === 'piet') tex = textures.piet;
            else if (sprite.type === 'paper') tex = textures.paper;

            if (sprite.type === 'piet') ctx.globalAlpha = 0.9;
            else ctx.globalAlpha = 1.0;

            for (let stripe = Math.floor(drawStartX); stripe < Math.floor(drawEndX); stripe++) {
                let texX = Math.floor(256 * (stripe - (-spriteWidth / 2 + spriteScreenX)) * 64 / spriteWidth) / 256;
                let realTexX = Math.floor((stripe - (-spriteWidth / 2 + spriteScreenX)) * 128 / spriteWidth);
                
                if (transformY > 0 && stripe > 0 && stripe < SCREEN_WIDTH && transformY < zBuffer[stripe]) {
                    ctx.drawImage(tex, realTexX, 0, 1, 128, stripe, drawStartY, 1, drawEndY - drawStartY);
                    
                    let lightIntensity = 1.0 / (transformY * 0.3); 
                    if (lightIntensity > 1) lightIntensity = 1;
                    
                    let screenDist = Math.abs(stripe - SCREEN_WIDTH / 2) / (SCREEN_WIDTH / 2);
                    let beam = 1.0 - Math.pow(screenDist, 2);
                    lightIntensity *= beam;
                    
                    if (sprite.type !== 'paper') { 
                        ctx.fillStyle = `rgba(0,0,0,${1 - lightIntensity})`;
                        ctx.fillRect(stripe, drawStartY, 1, drawEndY - drawStartY);
                    }
                }
            }
            ctx.globalAlpha = 1.0;
        }
    }

    function gameLoop() {
        if(!gameRunning) return;
        updateGame();
        draw();
        requestAnimationFrame(gameLoop);
    }

    function endGame(win) {
        gameRunning = false;
        if(!win) {
            playScream();
            jumpscareOverlay.style.opacity = 1;
            let flashCount = 0;
            let flashInt = setInterval(() => {
                jumpscareOverlay.style.filter = `invert(${Math.random() > 0.5 ? 1 : 0}) contrast(2)`;
                jumpscareOverlay.style.transform = `scale(${1 + Math.random()*0.1})`;
                flashCount++;
                if(flashCount > 20) clearInterval(flashInt);
            }, 50);
            setTimeout(() => { showMenu(win); }, 3000);
        } else {
            showMenu(win);
        }
    }

    function showMenu(win) {
        let title = win ? "ONTSNAPT" : "DOOD";
        msgOverlay.querySelector('h1').innerText = title;
        msgOverlay.querySelector('h1').style.color = win ? "#4a4" : "#900";
        msgOverlay.querySelector('p').innerText = win ? "Je bent vrij." : "Geen genade.";
        msgOverlay.querySelectorAll('p')[1].innerText = "";
        startBtn.innerText = "OPNIEUW";
        msgOverlay.classList.remove('hidden');
        jumpscareOverlay.style.opacity = 0;
    }
</script>
</body>
</html>
