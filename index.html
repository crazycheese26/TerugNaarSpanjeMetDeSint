<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>De Wraak van de Sint - 3D Horror</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Creepster&family=Nosifer&family=Roboto:wght@400;700&display=swap');

        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            color: #d00;
            font-family: 'Roboto', sans-serif;
            overflow: hidden;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Retro pixelated look */
        canvas {
            image-rendering: pixelated; 
            width: 100%;
            height: 100%;
            max-width: 100%;
            max-height: 100%;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        #score-display {
            color: #e6b800; /* Gold */
            font-family: 'Creepster', cursive;
            font-size: 3rem;
            text-shadow: 2px 2px 0 #000, 0 0 10px #ff0000;
        }

        #stamina-bar-container {
            width: 300px;
            height: 25px;
            background: #222;
            border: 3px solid #500;
            align-self: flex-start;
            margin-top: 10px;
            box-shadow: 0 0 10px #000;
        }

        #stamina-bar {
            width: 100%;
            height: 100%;
            background: #00cc00;
            transition: width 0.1s;
        }

        #message-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            pointer-events: auto;
            text-align: center;
        }
        
        #jumpscare-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 200;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.1s;
        }
        
        #jumpscare-img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        h1 {
            font-family: 'Nosifer', cursive;
            font-size: 4rem;
            color: #ff0000;
            margin-bottom: 20px;
            animation: pulse 2s infinite;
            text-shadow: 0 5px 10px #000;
        }

        p {
            color: #ccc;
            font-size: 1.2rem;
            max-width: 600px;
            margin: 0 auto 30px auto;
            line-height: 1.5;
            text-shadow: 1px 1px 2px #000;
        }

        button {
            background: #500;
            color: #fff;
            border: 2px solid #f00;
            padding: 20px 40px;
            font-size: 2rem;
            font-family: 'Creepster', cursive;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
        }

        button:hover {
            background: #f00;
            box-shadow: 0 0 30px #f00;
            transform: scale(1.05);
        }

        .hidden {
            display: none !important;
        }

        /* Blood overlay vignette */
        #vignette {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, transparent 50%, rgba(0,0,0,0.8) 90%, black 100%);
            pointer-events: none;
            z-index: 10;
        }

        #damage-flash {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: red;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s;
            z-index: 11;
        }

        @keyframes pulse {
            0% { text-shadow: 0 0 10px #500; }
            50% { text-shadow: 0 0 25px #f00; transform: scale(1.02); }
            100% { text-shadow: 0 0 10px #500; }
        }

        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            20% { transform: translate(-3px, 0px) rotate(1deg); }
            40% { transform: translate(1px, -1px) rotate(1deg); }
            60% { transform: translate(-3px, 1px) rotate(0deg); }
            80% { transform: translate(-1px, -1px) rotate(1deg); }
            100% { transform: translate(1px, -2px) rotate(-1deg); }
        }

        .shaking {
            animation: shake 0.5s;
            animation-iteration-count: infinite;
        }
        
        #controls-hint {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            color: #888;
            font-family: 'Creepster', cursive;
            font-size: 1.2rem;
            text-shadow: 1px 1px 0 #000;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <div id="vignette"></div>
    <div id="damage-flash"></div>
    <div id="jumpscare-overlay"></div>
    
    <div id="ui-layer">
        <div>
            <div id="score-display">Wortels: 0 / 3</div>
            <div id="stamina-bar-container"><div id="stamina-bar"></div></div>
        </div>
        <div id="controls-hint" class="hidden">W/S: Lopen | A/D: Draaien | SHIFT: Rennen</div>
    </div>

    <div id="message-overlay">
        <h1>ONTSNAP AAN DE SINT</h1>
        <p>DOOM EDITIE</p>
        <p>Je zit gevangen in een 3D doolhof. Vind de <strong>3 Gouden Wortels</strong>. Volg de bloedsporen... als je durft.</p>
        <button id="start-btn">START</button>
    </div>
</div>

<script>
    // --- Configuration (Doom Style) ---
    const MAP_WIDTH = 25;
    const MAP_HEIGHT = 18;
    const SCREEN_WIDTH = 640;  
    const SCREEN_HEIGHT = 360;
    const FOV = 0.66; 
    
    // Speeds
    const MOVE_SPEED = 0.08;
    const RUN_SPEED = 0.14;
    const ROT_SPEED = 0.06;
    
    // --- Audio ---
    let audioCtx;
    let droneOsc;
    
    // --- Game State ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d', { alpha: false }); 
    const uiLayer = document.getElementById('ui-layer');
    const msgOverlay = document.getElementById('message-overlay');
    const jumpscareOverlay = document.getElementById('jumpscare-overlay');
    const startBtn = document.getElementById('start-btn');
    const scoreDisplay = document.getElementById('score-display');
    const staminaBar = document.getElementById('stamina-bar');
    const controlsHint = document.getElementById('controls-hint');
    const gameContainer = document.getElementById('game-container');
    const damageFlash = document.getElementById('damage-flash');

    let gameRunning = false;
    let keys = {};
    let carrotsCollected = 0;
    let stamina = 100;
    let sintProximity = 0;
    let zBuffer = []; 
    let startTime = 0; // For difficulty scaling
    
    // Hallucination State
    let hallucinations = []; // Array of active piet sprites
    let lastHallucinationCheck = 0;

    // Map: 0=Floor, 1=Wall, 2=Start, 3=Exit, 4=Carrot, 5=Bloody Wall Hint
    const mapLayout = [
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
        [1,2,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,1,1,1,0,1,0,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1],
        [1,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,1],
        [1,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,1,1],
        [1,0,0,0,1,4,0,0,0,0,0,0,0,0,0,0,5,4,1,0,0,0,0,0,1], // Added hint (5)
        [1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,0,1],
        [1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,1,1,1,1,0,1,1,0,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1],
        [1,0,0,0,0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1],
        [1,1,1,1,0,1,0,1,0,1,1,1,1,0,1,1,0,1,1,1,1,0,1,1,1],
        [1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,4,0,1,0,0,0,1],
        [1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,1,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1],
        [1,0,0,0,5,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,1], // Added hint (5) near carrot path
        [1,3,1,0,0,0,1,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,1,1,1],
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
    ];

    // Player (camera)
    let posX = 0, posY = 0; 
    let dirX = -1, dirY = 0; 
    let planeX = 0, planeY = 0.66; 

    // Entities
    let sint = { x: 0, y: 0, active: true };
    let sprites = []; 
    
    // Textures
    const texWidth = 64;
    const texHeight = 64;
    let textures = {}; 

    // --- Texture Generation ---
    function generateTextures() {
        function createTexture(color1, color2, type) {
            const c = document.createElement('canvas');
            c.width = texWidth; c.height = texHeight;
            const cx = c.getContext('2d');
            
            // Background
            cx.fillStyle = color1;
            cx.fillRect(0,0,64,64);

            if (type === 'wall' || type === 'wall_bloody') {
                // Bricks
                cx.fillStyle = color2;
                for(let i=0; i<100; i++) cx.fillRect(Math.random()*64, Math.random()*64, 2, 2); 
                cx.fillStyle = 'rgba(0,0,0,0.3)';
                cx.fillRect(0, 0, 64, 2); 
                cx.fillRect(0, 32, 64, 2); 
                cx.fillRect(0, 0, 2, 32); 
                cx.fillRect(32, 32, 2, 32); 

                if (type === 'wall_bloody') {
                    // Blood stains / Hints
                    cx.fillStyle = '#800';
                    cx.beginPath();
                    cx.arc(32, 32, 20, 0, Math.PI*2);
                    cx.fill();
                    // Drips
                    cx.fillRect(28, 32, 4, 30);
                    cx.fillRect(36, 32, 2, 20);
                    cx.fillStyle = '#f00';
                    cx.font = 'bold 20px Arial';
                    cx.fillText("?", 25, 38);
                }
            } else if (type === 'exit') {
                cx.fillStyle = '#0f0';
                cx.font = '30px Arial';
                cx.fillText("UIT", 5, 40);
                cx.strokeStyle = '#fff';
                cx.lineWidth = 4;
                cx.strokeRect(2,2,60,60);
            }
            return c;
        }

        function createSprite(type) {
            const c = document.createElement('canvas');
            c.width = 64; c.height = 64;
            const cx = c.getContext('2d');
            
            if (type === 'carrot') {
                cx.fillStyle = 'orange';
                cx.beginPath(); cx.moveTo(32, 60); cx.lineTo(15, 15); cx.lineTo(49, 15); cx.fill();
                cx.fillStyle = '#0f0'; // Leaf
                cx.fillRect(28, 0, 8, 15);
                cx.strokeStyle = 'yellow'; cx.lineWidth=2; cx.stroke();
            } else if (type === 'sint') {
                // Mitre
                cx.fillStyle = '#900';
                cx.beginPath(); cx.moveTo(10, 30); cx.lineTo(32, 5); cx.lineTo(54, 30); cx.lineTo(54, 60); cx.lineTo(10, 60); cx.fill();
                cx.fillStyle = '#eb0'; cx.fillRect(28, 15, 8, 30); cx.fillRect(18, 25, 28, 8);
                cx.fillStyle = '#fff'; 
                cx.beginPath(); cx.arc(24, 45, 3, 0, Math.PI*2); cx.arc(40, 45, 3, 0, Math.PI*2); cx.fill();
                cx.fillStyle = '#f00'; 
                cx.beginPath(); cx.arc(24, 45, 1, 0, Math.PI*2); cx.arc(40, 45, 1, 0, Math.PI*2); cx.fill();
            } else if (type === 'piet') {
                // Scary shadow figure
                cx.fillStyle = '#000'; // Dark skin/suit (Shadowy)
                cx.beginPath(); cx.arc(32, 20, 10, 0, Math.PI*2); cx.fill(); // Head
                cx.fillRect(22, 30, 20, 34); // Body
                // Feather
                cx.strokeStyle = '#f0f'; cx.lineWidth=3; cx.beginPath(); cx.moveTo(32, 10); cx.lineTo(45, 0); cx.stroke();
                // Eyes
                cx.fillStyle = '#fff';
                cx.fillRect(28, 18, 2, 2); cx.fillRect(34, 18, 2, 2);
            }
            return c;
        }

        function createJumpscare() {
            const c = document.createElement('canvas');
            c.width = 300; c.height = 300;
            const cx = c.getContext('2d');
            // Background
            cx.fillStyle = '#000';
            cx.fillRect(0,0,300,300);
            // Scary Face
            cx.fillStyle = '#f00';
            cx.beginPath(); cx.arc(150, 150, 100, 0, Math.PI*2); cx.fill();
            cx.fillStyle = '#000';
            // Eyes
            cx.beginPath(); cx.ellipse(110, 130, 20, 40, 0, 0, Math.PI*2); cx.fill();
            cx.beginPath(); cx.ellipse(190, 130, 20, 40, 0, 0, Math.PI*2); cx.fill();
            // Mouth
            cx.beginPath(); cx.moveTo(100, 200); cx.quadraticCurveTo(150, 280, 200, 200); cx.fill();
            // Pupils
            cx.fillStyle = '#fff';
            cx.beginPath(); cx.arc(110, 130, 5, 0, Math.PI*2); cx.fill();
            cx.beginPath(); cx.arc(190, 130, 5, 0, Math.PI*2); cx.fill();
            return c;
        }

        textures.wall = createTexture('#444', '#555', 'wall'); 
        textures.wall_bloody = createTexture('#444', '#555', 'wall_bloody');
        textures.exit = createTexture('#050', '#0a0', 'exit');
        textures.carrot = createSprite('carrot');
        textures.sint = createSprite('sint');
        textures.piet = createSprite('piet');
        
        const jumpCanvas = createJumpscare();
        const jumpImg = document.createElement('img');
        jumpImg.src = jumpCanvas.toDataURL();
        jumpImg.id = "jumpscare-img";
        jumpscareOverlay.appendChild(jumpImg);
    }

    // --- Initialization ---

    function initGame() {
        canvas.width = SCREEN_WIDTH;
        canvas.height = SCREEN_HEIGHT;
        generateTextures();
        
        sprites = [];
        hallucinations = [];
        
        // Parse Map
        for(let y=0; y<MAP_HEIGHT; y++) {
            for(let x=0; x<MAP_WIDTH; x++) {
                let type = mapLayout[y][x];
                if(type === 2) { // Start
                    posX = x + 0.5;
                    posY = y + 0.5;
                    dirX = 1; dirY = 0;
                    planeX = 0; planeY = 0.66;
                } else if(type === 4) { // Carrot
                    sprites.push({ x: x+0.5, y: y+0.5, type: 'carrot', active: true });
                } else if(type === 3) {
                    sprites.push({ x: x+0.5, y: y+0.5, type: 'exit', active: true });
                }
            }
        }

        sint = { x: MAP_WIDTH - 2.5, y: MAP_HEIGHT - 2.5, type: 'sint', active: true };
        sprites.push(sint);
        
        carrotsCollected = 0;
        stamina = 100;
        gameRunning = true;
        startTime = Date.now();
        
        scoreDisplay.innerText = "Wortels: 0 / 3";
        msgOverlay.classList.add('hidden');
        jumpscareOverlay.style.opacity = 0;
        controlsHint.classList.remove('hidden');
        damageFlash.style.opacity = 0;
        
        initAudio();
        requestAnimationFrame(gameLoop);
    }

    // --- Input Handling ---

    window.addEventListener('keydown', (e) => {
        keys[e.key.toLowerCase()] = true;
        if(e.shiftKey) keys['shift'] = true;
    });

    window.addEventListener('keyup', (e) => {
        keys[e.key.toLowerCase()] = false;
        if(!e.shiftKey) keys['shift'] = false;
    });

    startBtn.addEventListener('click', () => {
        initGame();
    });

    // --- Physics & Logic ---

    function updateGame() {
        let now = Date.now();
        
        // Rotation
        if (keys['d'] || keys['arrowright']) {
            let oldDirX = dirX;
            dirX = dirX * Math.cos(ROT_SPEED) - dirY * Math.sin(ROT_SPEED);
            dirY = oldDirX * Math.sin(ROT_SPEED) + dirY * Math.cos(ROT_SPEED);
            let oldPlaneX = planeX;
            planeX = planeX * Math.cos(ROT_SPEED) - planeY * Math.sin(ROT_SPEED);
            planeY = oldPlaneX * Math.sin(ROT_SPEED) + planeY * Math.cos(ROT_SPEED);
        }
        if (keys['a'] || keys['arrowleft']) {
            let oldDirX = dirX;
            dirX = dirX * Math.cos(-ROT_SPEED) - dirY * Math.sin(-ROT_SPEED);
            dirY = oldDirX * Math.sin(-ROT_SPEED) + dirY * Math.cos(-ROT_SPEED);
            let oldPlaneX = planeX;
            planeX = planeX * Math.cos(-ROT_SPEED) - planeY * Math.sin(-ROT_SPEED);
            planeY = oldPlaneX * Math.sin(-ROT_SPEED) + planeY * Math.cos(-ROT_SPEED);
        }

        // Move
        let currentSpeed = MOVE_SPEED;
        if (keys['shift'] && stamina > 0) {
            currentSpeed = RUN_SPEED;
            stamina -= 1;
        } else {
            stamina = Math.min(100, stamina + 0.5);
        }
        staminaBar.style.width = stamina + "%";
        staminaBar.style.background = stamina < 20 ? "#f00" : "#00cc00";

        // Collision Check (Treat walls 1 and 5 as blocking)
        function isBlocking(val) { return val === 1 || val === 5; }

        if (keys['w'] || keys['arrowup']) {
            if(!isBlocking(mapLayout[Math.floor(posY)][Math.floor(posX + dirX * currentSpeed * 2)])) posX += dirX * currentSpeed;
            if(!isBlocking(mapLayout[Math.floor(posY + dirY * currentSpeed * 2)][Math.floor(posX)])) posY += dirY * currentSpeed;
        }
        if (keys['s'] || keys['arrowdown']) {
            if(!isBlocking(mapLayout[Math.floor(posY)][Math.floor(posX - dirX * currentSpeed * 2)])) posX -= dirX * currentSpeed;
            if(!isBlocking(mapLayout[Math.floor(posY - dirY * currentSpeed * 2)][Math.floor(posX)])) posY -= dirY * currentSpeed;
        }

        // --- Zwarte Piet Hallucinations ---
        if (now - lastHallucinationCheck > 2000) { // Check every 2s
            lastHallucinationCheck = now;
            // Chance to spawn
            if (hallucinations.length === 0 && Math.random() < 0.3) {
                // Spawn vector: 8-12 units ahead
                let spawnDist = 8 + Math.random() * 4;
                let hX = posX + dirX * spawnDist;
                let hY = posY + dirY * spawnDist;
                
                // Ensure valid location (empty space)
                if (hX > 0 && hX < MAP_WIDTH && hY > 0 && hY < MAP_HEIGHT) {
                    if (mapLayout[Math.floor(hY)][Math.floor(hX)] === 0) {
                        let piet = { x: hX, y: hY, type: 'piet', active: true, spawnTime: now };
                        hallucinations.push(piet);
                        sprites.push(piet);
                    }
                }
            }
        }
        
        // Update Hallucinations
        for(let i = hallucinations.length - 1; i >= 0; i--) {
            let p = hallucinations[i];
            let distToPiet = Math.hypot(posX - p.x, posY - p.y);
            
            // Vanish if too close or too old
            if (distToPiet < 3 || (now - p.spawnTime > 4000)) {
                p.active = false; // For renderer
                hallucinations.splice(i, 1);
                // Remove from sprites array
                let spriteIndex = sprites.indexOf(p);
                if (spriteIndex > -1) sprites.splice(spriteIndex, 1);
            }
        }


        // --- Sint AI & Dynamic Speed ---
        // Base speed 0.02, increases by 0.0005 every second
        let timeAlive = (now - startTime) / 1000;
        let sintSpeed = 0.02 + (timeAlive * 0.0002);
        if (carrotsCollected === 3) sintSpeed += 0.02; // Enrage bonus
        // Cap speed
        if (sintSpeed > 0.065) sintSpeed = 0.065;

        let dx = posX - sint.x;
        let dy = posY - sint.y;
        let dist = Math.sqrt(dx*dx + dy*dy);
        
        if (dist > 0.5) {
            let sx = dx / dist * sintSpeed;
            let sy = dy / dist * sintSpeed;
            
            if (!isBlocking(mapLayout[Math.floor(sint.y)][Math.floor(sint.x + sx * 1.5)])) sint.x += sx;
            if (!isBlocking(mapLayout[Math.floor(sint.y + sy * 1.5)][Math.floor(sint.x)])) sint.y += sy;
        }

        sintProximity = Math.max(0, 1 - (dist / 10)); 
        updateSound();

        if (dist < 0.5) {
            endGame(false);
        }

        // Item Pickup
        sprites.forEach(s => {
            if (!s.active || s.type === 'piet' || s.type === 'sint') return;
            let d = Math.sqrt((posX - s.x)**2 + (posY - s.y)**2);
            if (d < 0.5) {
                if (s.type === 'carrot') {
                    s.active = false;
                    carrotsCollected++;
                    scoreDisplay.innerText = `Wortels: ${carrotsCollected} / 3`;
                    playSound('pickup');
                    if(carrotsCollected === 3) {
                        scoreDisplay.innerText = "VIND DE UITGANG!";
                        scoreDisplay.style.color = "#fff";
                    }
                } else if (s.type === 'exit' && carrotsCollected >= 3) {
                    endGame(true);
                }
            }
        });
    }

    // --- Audio System ---
    
    function initAudio() {
        if (!audioCtx) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if(audioCtx.state === 'suspended') audioCtx.resume();

        if(!droneOsc) {
            droneOsc = audioCtx.createOscillator();
            let gain = audioCtx.createGain();
            droneOsc.type = 'sawtooth';
            droneOsc.frequency.value = 40;
            droneOsc.connect(gain);
            gain.connect(audioCtx.destination);
            gain.gain.value = 0.05;
            droneOsc.start();
            droneOsc.gainNode = gain;
        }
    }

    function updateSound() {
        if(!droneOsc) return;
        droneOsc.frequency.value = 40 + (sintProximity * 80);
        let vol = 0.05 + (sintProximity * 0.1);
        droneOsc.gainNode.gain.value = vol;

        if(sintProximity > 0.6) {
            gameContainer.classList.add('shaking');
        } else {
            gameContainer.classList.remove('shaking');
        }
    }

    function playSound(type) {
        if(!audioCtx) return;
        let osc = audioCtx.createOscillator();
        let gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);

        if(type === 'pickup') {
            osc.type = 'square';
            osc.frequency.setValueAtTime(600, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(1200, audioCtx.currentTime + 0.1);
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.2);
        } else if (type === 'scream') {
            // Jumpscare Scream
            osc.type = 'sawtooth';
            // Discordant tritone sweep
            osc.frequency.setValueAtTime(600, audioCtx.currentTime);
            osc.frequency.linearRampToValueAtTime(100, audioCtx.currentTime + 0.3);
            
            let osc2 = audioCtx.createOscillator();
            osc2.type = 'square';
            osc2.frequency.setValueAtTime(450, audioCtx.currentTime);
            osc2.frequency.linearRampToValueAtTime(50, audioCtx.currentTime + 0.4);
            osc2.connect(gain);

            gain.gain.setValueAtTime(1.0, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 1.5);
            
            osc.start();
            osc2.start();
            osc.stop(audioCtx.currentTime + 1.5);
            osc2.stop(audioCtx.currentTime + 1.5);
        }
    }

    // --- Raycasting Engine ---

    function draw() {
        ctx.fillStyle = '#111'; // Ceiling
        ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT / 2);
        ctx.fillStyle = '#1a1a1a'; // Floor
        ctx.fillRect(0, SCREEN_HEIGHT / 2, SCREEN_WIDTH, SCREEN_HEIGHT / 2);

        zBuffer = []; 

        for (let x = 0; x < SCREEN_WIDTH; x++) {
            let cameraX = 2 * x / SCREEN_WIDTH - 1;
            let rayDirX = dirX + planeX * cameraX;
            let rayDirY = dirY + planeY * cameraX;

            let mapX = Math.floor(posX);
            let mapY = Math.floor(posY);

            let sideDistX, sideDistY;
            let deltaDistX = Math.abs(1 / rayDirX);
            let deltaDistY = Math.abs(1 / rayDirY);
            let perpWallDist;

            let stepX, stepY;
            let hit = 0;
            let side; 
            let wallType = 1;

            if (rayDirX < 0) {
                stepX = -1;
                sideDistX = (posX - mapX) * deltaDistX;
            } else {
                stepX = 1;
                sideDistX = (mapX + 1.0 - posX) * deltaDistX;
            }
            if (rayDirY < 0) {
                stepY = -1;
                sideDistY = (posY - mapY) * deltaDistY;
            } else {
                stepY = 1;
                sideDistY = (mapY + 1.0 - posY) * deltaDistY;
            }

            while (hit === 0) {
                if (sideDistX < sideDistY) {
                    sideDistX += deltaDistX;
                    mapX += stepX;
                    side = 0;
                } else {
                    sideDistY += deltaDistY;
                    mapY += stepY;
                    side = 1;
                }
                
                let tile = mapLayout[mapY][mapX];
                if (tile === 1 || tile === 5) {
                    hit = 1;
                    wallType = tile;
                }
            }

            if (side === 0) perpWallDist = (mapX - posX + (1 - stepX) / 2) / rayDirX;
            else            perpWallDist = (mapY - posY + (1 - stepY) / 2) / rayDirY;

            zBuffer[x] = perpWallDist; 

            let lineHeight = Math.floor(SCREEN_HEIGHT / perpWallDist);
            let drawStart = -lineHeight / 2 + SCREEN_HEIGHT / 2;
            if (drawStart < 0) drawStart = 0;
            let drawEnd = lineHeight / 2 + SCREEN_HEIGHT / 2;
            if (drawEnd >= SCREEN_HEIGHT) drawEnd = SCREEN_HEIGHT - 1;

            let wallX; 
            if (side == 0) wallX = posY + perpWallDist * rayDirY;
            else           wallX = posX + perpWallDist * rayDirX;
            wallX -= Math.floor(wallX);

            let texX = Math.floor(wallX * texWidth);
            if(side == 0 && rayDirX > 0) texX = texWidth - texX - 1;
            if(side == 1 && rayDirY < 0) texX = texWidth - texX - 1;

            let brightness = 1.0 / (perpWallDist * 0.5); 
            if (brightness > 1) brightness = 1;
            if (side === 1) brightness *= 0.7;

            // Choose Texture based on Wall Type
            let tex = (wallType === 5) ? textures.wall_bloody : textures.wall;

            ctx.globalAlpha = 1.0; 
            ctx.drawImage(tex, texX, 0, 1, texHeight, x, drawStart, 1, drawEnd - drawStart);
            
            ctx.fillStyle = `rgba(0,0,0,${1 - brightness})`;
            ctx.fillRect(x, drawStart, 1, drawEnd - drawStart);
        }

        // --- Sprite Casting ---
        sprites.forEach(sprite => {
            sprite.dist = ((posX - sprite.x) * (posX - sprite.x) + (posY - sprite.y) * (posY - sprite.y));
        });
        sprites.sort((a, b) => b.dist - a.dist);

        for (let i = 0; i < sprites.length; i++) {
            if(!sprites[i].active) continue;

            let sprite = sprites[i];
            let spriteX = sprite.x - posX;
            let spriteY = sprite.y - posY;

            let invDet = 1.0 / (planeX * dirY - dirX * planeY);
            let transformX = invDet * (dirY * spriteX - dirX * spriteY);
            let transformY = invDet * (-planeY * spriteX + planeX * spriteY); 

            let spriteScreenX = Math.floor((SCREEN_WIDTH / 2) * (1 + transformX / transformY));

            let spriteHeight = Math.abs(Math.floor(SCREEN_HEIGHT / transformY));
            let drawStartY = -spriteHeight / 2 + SCREEN_HEIGHT / 2;
            if (drawStartY < 0) drawStartY = 0;
            let drawEndY = spriteHeight / 2 + SCREEN_HEIGHT / 2;
            if (drawEndY >= SCREEN_HEIGHT) drawEndY = SCREEN_HEIGHT - 1;

            let spriteWidth = Math.abs(Math.floor(SCREEN_HEIGHT / transformY));
            let drawStartX = -spriteWidth / 2 + spriteScreenX;
            let drawEndX = spriteWidth / 2 + spriteScreenX;
            if (drawStartX < 0) drawStartX = 0;
            if (drawEndX >= SCREEN_WIDTH) drawEndX = SCREEN_WIDTH - 1;

            let tex = textures.carrot;
            if (sprite.type === 'exit') tex = textures.exit;
            else if (sprite.type === 'sint') tex = textures.sint;
            else if (sprite.type === 'piet') tex = textures.piet;

            // Piet transparency (ghost effect)
            if (sprite.type === 'piet') ctx.globalAlpha = 0.6;
            else ctx.globalAlpha = 1.0;

            for (let stripe = Math.floor(drawStartX); stripe < Math.floor(drawEndX); stripe++) {
                let texX = Math.floor(256 * (stripe - (-spriteWidth / 2 + spriteScreenX)) * texWidth / spriteWidth) / 256;
                
                if (transformY > 0 && stripe > 0 && stripe < SCREEN_WIDTH && transformY < zBuffer[stripe]) {
                    ctx.drawImage(tex, texX, 0, 1, texHeight, stripe, drawStartY, 1, drawEndY - drawStartY);
                    
                    let brightness = 1.0 / (transformY * 0.5);
                    if (brightness > 1) brightness = 1;
                    if (brightness < 0) brightness = 0;
                    ctx.fillStyle = `rgba(0,0,0,${1 - brightness})`;
                    ctx.fillRect(stripe, drawStartY, 1, drawEndY - drawStartY);
                }
            }
            ctx.globalAlpha = 1.0;
        }
    }

    function gameLoop() {
        if(!gameRunning) return;
        updateGame();
        draw();
        requestAnimationFrame(gameLoop);
    }

    function endGame(win) {
        gameRunning = false;
        gameContainer.classList.remove('shaking');
        
        if(!win) {
            playSound('scream');
            // Jumpscare
            jumpscareOverlay.style.opacity = 1;
            // Delay showing the menu so they see the scare
            setTimeout(() => {
                showMenu(win);
            }, 2000);
        } else {
            showMenu(win);
        }
        
        if(droneOsc) {
            droneOsc.stop();
            droneOsc = null;
        }
    }

    function showMenu(win) {
        let title = win ? "ONTSNAPT!" : "GEPAKT!";
        let desc = win 
            ? "Je hebt de uitgang gevonden. Het Sinterklaasfeest is gered... voor jou." 
            : "Sinterklaas heeft je gevonden. Volgend jaar ben jij Zwarte Piet.";
        let btnText = "OPNIEUW";
        let color = win ? "#0f0" : "#f00";

        msgOverlay.querySelector('h1').innerText = title;
        msgOverlay.querySelector('h1').style.color = color;
        msgOverlay.querySelector('p').innerText = desc;
        msgOverlay.querySelectorAll('p')[1].innerText = "";
        startBtn.innerText = btnText;
        msgOverlay.classList.remove('hidden');
        controlsHint.classList.add('hidden');
        jumpscareOverlay.style.opacity = 0;
    }

</script>
</body>
</html>
