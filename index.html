<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>De Wraak van de Sint - Lore Edition</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Creepster&family=Nosifer&family=Roboto:wght@400;700&family=Caveat:wght@700&display=swap');

        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            color: #a00;
            font-family: 'Roboto', sans-serif;
            overflow: hidden;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* CRT/VHS Effects - Brightness bumped up slightly to fix black screen */
        canvas {
            image-rendering: pixelated; 
            width: 100%;
            height: 100%;
            filter: contrast(1.2) brightness(1.1) sepia(0.3) hue-rotate(-5deg); 
        }

        .scanlines {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2));
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 50;
        }

        .noise {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMDAiIGhlaWdodD0iMjAwIj48ZmlsdGVyIGlkPSJub2lzZSI+PGZlVHVyYnVsZW5jZSB0eXBlPSJmcmFjdGFsTm9pc2UiIGJhc2VGcmVxdWVuY3k9IjAuNjUiIG51bU9jdGF2ZXM9IjMiIHN0aXRjaFRpbGVzPSJzdGl0Y2giLz48L2ZpbHRlcj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWx0ZXI9InVybCgjbm9pc2UpIiBvcGFjaXR5PSIwLjA4Ii8+PC9zdmc+');
            pointer-events: none;
            z-index: 51;
            opacity: 0.1;
            animation: noiseAnim 0.2s infinite;
        }

        @keyframes noiseAnim {
            0% { transform: translate(0,0); }
            100% { transform: translate(10px,10px); }
        }

        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
            z-index: 60;
        }

        #lore-text {
            position: absolute;
            bottom: 20%;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Caveat', cursive;
            font-size: 2rem;
            color: #ddd;
            text-shadow: 2px 2px 4px #000;
            text-align: center;
            opacity: 0;
            transition: opacity 0.5s;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #444;
            max-width: 80%;
            pointer-events: none;
        }

        #score-display {
            color: #888;
            font-family: 'Creepster', cursive;
            font-size: 2rem;
            opacity: 0.7;
            text-shadow: 2px 2px 0 #000;
        }

        #message-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #050000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            pointer-events: auto;
            text-align: center;
        }
        
        #jumpscare-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 200;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.05s;
        }
        
        #jumpscare-img { width: 100%; height: 100%; object-fit: cover; }

        h1 {
            font-family: 'Nosifer', cursive;
            font-size: 4rem;
            color: #b00;
            margin-bottom: 20px;
            text-shadow: 4px 4px 0px #000;
        }

        p {
            color: #666;
            font-size: 1.1rem;
            max-width: 500px;
            margin: 0 auto 30px auto;
            line-height: 1.6;
            font-family: monospace;
        }

        button {
            background: #100;
            color: #800;
            border: 1px solid #400;
            padding: 20px 40px;
            font-size: 1.5rem;
            font-family: 'Creepster', cursive;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        button:hover {
            background: #300;
            color: #f00;
            box-shadow: 0 0 20px #500;
        }

        .hidden { display: none !important; }

        #vignette {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 30%, rgba(0,0,0,0.8) 70%, black 100%);
            pointer-events: none;
            z-index: 55;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <div class="scanlines"></div>
    <div class="noise"></div>
    <div id="vignette"></div>
    <div id="jumpscare-overlay"></div>
    
    <div id="ui-layer">
        <div>
            <div id="score-display">VIND DE DEUR</div>
        </div>
        <div id="lore-text"></div>
        <div id="controls-hint" style="color:#444; font-family: monospace;">WASD / Shift</div>
    </div>

    <div id="message-overlay">
        <h1>VERLOREN ZIELEN</h1>
        <p>Lees de notities van zij die faalden. Leer van hun fouten.</p>
        <p>Hij is geen heilige. Hij is hongerig.</p>
        <button id="start-btn">BETREDEN</button>
    </div>
</div>

<script>
    // --- Configuration ---
    const MAP_WIDTH = 45;
    const MAP_HEIGHT = 35;
    const SCREEN_WIDTH = 320; 
    const SCREEN_HEIGHT = 180;
    
    const MOVE_SPEED = 0.07;
    const RUN_SPEED = 0.12;
    const ROT_SPEED = 0.05;
    
    // --- Audio ---
    let audioCtx;
    let nextAmbientSoundTime = 0;
    
    // --- Game State ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d', { alpha: false }); 
    const msgOverlay = document.getElementById('message-overlay');
    const jumpscareOverlay = document.getElementById('jumpscare-overlay');
    const startBtn = document.getElementById('start-btn');
    const loreTextEl = document.getElementById('lore-text');

    let gameRunning = false;
    let keys = {};
    let sintProximity = 0;
    let zBuffer = []; 
    let startTime = 0; 
    let frameCount = 0;
    
    let hallucinations = [];
    let lastHallucinationCheck = 0;

    let mapLayout = [];

    // Player
    let posX = 0, posY = 0; 
    let dirX = -1, dirY = 0; 
    let planeX = 0, planeY = 0.66; 

    // Entities
    let sint = { x: 0, y: 0, active: true };
    let sprites = []; 
    
    // Lore Database
    const loreMessages = [
        "Dag 4. Het is hier zo koud. De Pieten praten niet, ze staren alleen.",
        "Hij is geen heiligman. Ik zag hem iets eten... het was geen marsepein.",
        "De deur verandert van plek. Het doolhof leeft.",
        "Kijk hem niet in de ogen. Hij ruikt je angst.",
        "5 December is geen feestdag. Het is een offerdag.",
        "Ik hoor de bellen... ze komen dichterbij.",
        "Er is geen weg terug naar Spanje. Dit is de hel."
    ];

    const wallMessages = ["HIJ ZIET JE", "REN", "GEEN UITGANG", "DOOD", "5 DEC", "†"];

    // Textures
    const texWidth = 64;
    const texHeight = 64;
    let textures = {}; 

    // --- Texture Generation ---
    function generateTextures() {
        function createTexture(color1, color2, type, variant) {
            const c = document.createElement('canvas');
            c.width = texWidth; c.height = texHeight;
            const cx = c.getContext('2d');
            
            // Base Color (Significantly brightened from previous version to fix black screen)
            cx.fillStyle = color1; 
            cx.fillRect(0,0,64,64);
            
            // Gritty noise
            for(let i=0; i<300; i++) {
                cx.fillStyle = Math.random()>0.5 ? '#000' : '#222';
                cx.globalAlpha = 0.2;
                cx.fillRect(Math.random()*64, Math.random()*64, 2, 2);
            }
            cx.globalAlpha = 1.0;

            if (type.includes('wall')) {
                cx.fillStyle = color2;
                for(let i=0; i<6; i++) cx.fillRect(i*10 + Math.random()*4, 0, 4, 64);
                
                if (type === 'wall_bloody') {
                    cx.fillStyle = '#600'; // Brighter blood for visibility
                    cx.font = 'bold 16px Courier';
                    cx.save();
                    cx.translate(32, 32);
                    cx.rotate((Math.random()-0.5)*0.5);
                    let msg = wallMessages[variant % wallMessages.length];
                    cx.fillText(msg, -20, 5);
                    
                    // Drips
                    cx.fillRect(-10, 10, 2, 20);
                    cx.fillRect(10, 10, 3, 15);
                    cx.restore();
                }
            } 
            return c;
        }

        function createSprite(type) {
            const c = document.createElement('canvas');
            c.width = 128; c.height = 128;
            const cx = c.getContext('2d');
            
            if (type === 'paper') {
                // Glowing paper on floor
                cx.fillStyle = '#ffc';
                cx.fillRect(44, 100, 40, 28); // Paper
                cx.fillStyle = '#000';
                for(let i=0; i<4; i++) cx.fillRect(48, 105 + i*5, 30, 2); // Text lines
                // Glow
                cx.shadowBlur = 15; cx.shadowColor = '#ffc';
                cx.strokeStyle = '#ffc'; cx.strokeRect(44,100,40,28);
                cx.shadowBlur = 0;
            } else if (type === 'door') {
                cx.fillStyle = '#222'; cx.fillRect(30, 0, 68, 128); // Brighter door
                cx.strokeStyle = '#632'; cx.lineWidth = 4; cx.strokeRect(30, 0, 68, 128);
                cx.fillStyle = '#a00'; cx.font = '40px serif'; cx.fillText("Ω", 50, 80);
            } else if (type === 'sint') {
                // Taller, Scarier Sint
                cx.fillStyle = '#800'; // Robe - Brighter
                cx.beginPath(); cx.moveTo(40, 128); cx.lineTo(64, 20); cx.lineTo(88, 128); cx.fill();
                cx.fillStyle = '#600';
                cx.beginPath(); cx.moveTo(40, 128); cx.lineTo(30, 50); cx.lineTo(64, 20); cx.lineTo(98, 50); cx.lineTo(88, 128); cx.fill();
                cx.strokeStyle = '#d90'; cx.lineWidth = 4;
                cx.beginPath(); cx.moveTo(90, 128); cx.lineTo(100, 10); cx.stroke();
                cx.beginPath(); cx.arc(100, 10, 5, 0, Math.PI*2); cx.stroke();
                cx.fillStyle = '#eee'; 
                cx.beginPath(); cx.arc(64, 30, 12, 0, Math.PI*2); cx.fill();
                cx.fillStyle = '#a00';
                cx.beginPath(); cx.moveTo(50, 25); cx.lineTo(64, -10); cx.lineTo(78, 25); cx.fill();
                cx.strokeStyle = '#fa0'; cx.lineWidth=2;
                cx.beginPath(); cx.moveTo(64, -10); cx.lineTo(64, 25); cx.stroke();
                cx.fillStyle = '#f00'; 
                cx.shadowBlur = 10; cx.shadowColor = 'red';
                cx.beginPath(); cx.arc(60, 30, 2, 0, Math.PI*2); cx.fill();
                cx.beginPath(); cx.arc(68, 30, 2, 0, Math.PI*2); cx.fill();
                cx.shadowBlur = 0;
                cx.fillStyle = '#fff';
                cx.beginPath(); cx.moveTo(52, 35); cx.lineTo(64, 60); cx.lineTo(76, 35); cx.fill();
            } else if (type === 'piet') {
                cx.fillStyle = '#0a0a0a'; 
                cx.beginPath(); cx.ellipse(64, 80, 20, 40, 0, 0, Math.PI*2); cx.fill();
                cx.beginPath(); cx.arc(64, 40, 18, 0, Math.PI*2); cx.fill();
                cx.strokeStyle = '#505'; cx.lineWidth=3; 
                cx.beginPath(); cx.moveTo(64, 25); cx.lineTo(90, 10); cx.stroke();
                cx.fillStyle = '#fff';
                cx.shadowBlur = 5; cx.shadowColor = '#fff';
                cx.beginPath(); cx.arc(58, 40, 2, 0, Math.PI*2); cx.fill();
                cx.beginPath(); cx.arc(70, 40, 2, 0, Math.PI*2); cx.fill();
                cx.shadowBlur = 0;
            }
            return c;
        }

        function createJumpscare() {
            const c = document.createElement('canvas');
            c.width = 400; c.height = 400;
            const cx = c.getContext('2d');
            cx.fillStyle = '#000'; cx.fillRect(0,0,400,400);
            for(let i=0; i<1000; i++) {
                cx.fillStyle = Math.random()>0.8?'#f00':'#200';
                cx.fillRect(Math.random()*400, Math.random()*400, 5, 5);
            }
            cx.fillStyle = '#ccc';
            cx.beginPath(); cx.arc(200, 180, 120, 0, Math.PI*2); cx.fill();
            cx.fillRect(140, 180, 120, 150);
            cx.fillStyle = '#000';
            cx.beginPath(); cx.arc(150, 160, 30, 0, Math.PI*2); cx.fill();
            cx.beginPath(); cx.arc(250, 160, 30, 0, Math.PI*2); cx.fill();
            cx.beginPath(); cx.ellipse(200, 320, 60, 100, 0, 0, Math.PI*2); cx.fill();
            cx.fillStyle = '#ff9';
            for(let i=0; i<10; i++) {
                cx.fillRect(150 + i*10, 250, 5, 20); 
                cx.fillRect(150 + i*10, 380, 5, 20); 
            }
            return c;
        }

        // Updated texture colors: much brighter base to counter the darkness filter
        textures.wall = createTexture('#444', '#333', 'wall', 0); 
        textures.wall_bloody_1 = createTexture('#444', '#333', 'wall_bloody', 0);
        textures.wall_bloody_2 = createTexture('#444', '#333', 'wall_bloody', 1);
        textures.wall_bloody_3 = createTexture('#444', '#333', 'wall_bloody', 2);
        textures.door = createSprite('door');
        textures.paper = createSprite('paper');
        textures.sint = createSprite('sint');
        textures.piet = createSprite('piet');
        
        const jumpCanvas = createJumpscare();
        const jumpImg = document.createElement('img');
        jumpImg.src = jumpCanvas.toDataURL();
        jumpImg.id = "jumpscare-img";
        jumpscareOverlay.innerHTML = '';
        jumpscareOverlay.appendChild(jumpImg);
    }

    // --- Map Generation ---
    function generateMap() {
        let map = [];
        for(let y=0; y<MAP_HEIGHT; y++) {
            let row = [];
            for(let x=0; x<MAP_WIDTH; x++) row.push(1);
            map.push(row);
        }

        let stack = [];
        let startX = 1, startY = 1;
        map[startY][startX] = 0;
        stack.push({x: startX, y: startY});
        
        while(stack.length > 0) {
            let current = stack[stack.length - 1];
            let neighbors = [];
            let dirs = [{x: 0, y: -2}, {x: 0, y: 2}, {x: -2, y: 0}, {x: 2, y: 0}];
            for(let d of dirs) {
                let nx = current.x + d.x;
                let ny = current.y + d.y;
                if(nx > 0 && nx < MAP_WIDTH-1 && ny > 0 && ny < MAP_HEIGHT-1) {
                    if(map[ny][nx] === 1) neighbors.push({x: nx, y: ny, dx: d.x/2, dy: d.y/2});
                }
            }
            if(neighbors.length > 0) {
                let chosen = neighbors[Math.floor(Math.random() * neighbors.length)];
                map[current.y + chosen.dy][current.x + chosen.dx] = 0;
                map[chosen.y][chosen.x] = 0;
                stack.push({x: chosen.x, y: chosen.y});
            } else stack.pop();
        }
        
        for(let i=0; i<30; i++) {
            let rx = Math.floor(Math.random()*(MAP_WIDTH-2))+1;
            let ry = Math.floor(Math.random()*(MAP_HEIGHT-2))+1;
            if(map[ry][rx]===1) {
                if((map[ry-1][rx]===0 && map[ry+1][rx]===0) || (map[ry][rx-1]===0 && map[ry][rx+1]===0)) map[ry][rx]=0;
            }
        }

        posX = 1.5; posY = 1.5;

        // Place Lore Papers
        for(let i=0; i<10; i++) {
            let rx = Math.floor(Math.random() * MAP_WIDTH);
            let ry = Math.floor(Math.random() * MAP_HEIGHT);
            if(map[ry][rx] === 0) {
                let msg = loreMessages[Math.floor(Math.random() * loreMessages.length)];
                sprites.push({ x: rx+0.5, y: ry+0.5, type: 'paper', active: true, msg: msg });
                
                // Add bloody wall near paper
                if(map[ry][rx-1]===1) map[ry][rx-1] = 5 + Math.floor(Math.random()*3); // 5, 6, 7
            }
        }

        // Place Exit
        let placedExit = false;
        while(!placedExit) {
            let rx = Math.floor(Math.random() * MAP_WIDTH);
            let ry = Math.floor(Math.random() * MAP_HEIGHT);
            if(map[ry][rx] === 0 && Math.hypot(rx - posX, ry - posY) > 25) {
                sprites.push({ x: rx+0.5, y: ry+0.5, type: 'door', active: true });
                placedExit = true;
                if(map[ry][rx-1]===1) map[ry][rx-1]=5;
                else if(map[ry][rx+1]===1) map[ry][rx+1]=5;
            }
        }

        // Place Sint
        let placedSint = false;
        while(!placedSint) {
            let rx = Math.floor(Math.random() * MAP_WIDTH);
            let ry = Math.floor(Math.random() * MAP_HEIGHT);
            if(map[ry][rx] === 0 && Math.hypot(rx - posX, ry - posY) > 20) {
                sint = { x: rx+0.5, y: ry+0.5, type: 'sint', active: true };
                sprites.push(sint);
                placedSint = true;
            }
        }
        return map;
    }

    // --- Init ---
    function initGame() {
        canvas.width = SCREEN_WIDTH;
        canvas.height = SCREEN_HEIGHT;
        generateTextures();
        sprites = [];
        hallucinations = [];
        mapLayout = generateMap();
        
        dirX = -1; dirY = 0;
        planeX = 0; planeY = 0.66;
        
        gameRunning = true;
        startTime = Date.now();
        nextAmbientSoundTime = Date.now() + 2000;
        
        msgOverlay.classList.add('hidden');
        jumpscareOverlay.style.opacity = 0;
        initAudio();
        requestAnimationFrame(gameLoop);
    }

    window.addEventListener('keydown', (e) => { keys[e.key.toLowerCase()] = true; if(e.shiftKey) keys['shift'] = true; });
    window.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; if(!e.shiftKey) keys['shift'] = false; });
    startBtn.addEventListener('click', () => { initGame(); });

    // --- Update ---
    function updateGame() {
        let now = Date.now();
        frameCount++;

        if (keys['d'] || keys['arrowright']) {
            let oldDirX = dirX;
            dirX = dirX * Math.cos(-ROT_SPEED) - dirY * Math.sin(-ROT_SPEED);
            dirY = oldDirX * Math.sin(-ROT_SPEED) + dirY * Math.cos(-ROT_SPEED);
            let oldPlaneX = planeX;
            planeX = planeX * Math.cos(-ROT_SPEED) - planeY * Math.sin(-ROT_SPEED);
            planeY = oldPlaneX * Math.sin(-ROT_SPEED) + planeY * Math.cos(-ROT_SPEED);
        }
        if (keys['a'] || keys['arrowleft']) {
            let oldDirX = dirX;
            dirX = dirX * Math.cos(ROT_SPEED) - dirY * Math.sin(ROT_SPEED);
            dirY = oldDirX * Math.sin(ROT_SPEED) + dirY * Math.cos(ROT_SPEED);
            let oldPlaneX = planeX;
            planeX = planeX * Math.cos(ROT_SPEED) - planeY * Math.sin(ROT_SPEED);
            planeY = oldPlaneX * Math.sin(ROT_SPEED) + planeY * Math.cos(ROT_SPEED);
        }

        let currentSpeed = keys['shift'] ? RUN_SPEED : MOVE_SPEED;
        function isBlocking(val) { return val === 1 || (val >= 5 && val <= 7); }

        if (keys['w'] || keys['arrowup']) {
            if(!isBlocking(mapLayout[Math.floor(posY)][Math.floor(posX + dirX * currentSpeed * 2)])) posX += dirX * currentSpeed;
            if(!isBlocking(mapLayout[Math.floor(posY + dirY * currentSpeed * 2)][Math.floor(posX)])) posY += dirY * currentSpeed;
        }
        if (keys['s'] || keys['arrowdown']) {
            if(!isBlocking(mapLayout[Math.floor(posY)][Math.floor(posX - dirX * currentSpeed * 2)])) posX -= dirX * currentSpeed;
            if(!isBlocking(mapLayout[Math.floor(posY - dirY * currentSpeed * 2)][Math.floor(posX)])) posY -= dirY * currentSpeed;
        }

        // --- Lore Check ---
        let nearbyPaper = null;
        sprites.forEach(s => {
            if(s.type === 'paper') {
                let d = Math.sqrt((posX - s.x)**2 + (posY - s.y)**2);
                if(d < 1.0) nearbyPaper = s.msg;
            }
        });
        
        if(nearbyPaper) {
            loreTextEl.innerText = nearbyPaper;
            loreTextEl.style.opacity = 1;
        } else {
            loreTextEl.style.opacity = 0;
        }

        // --- Peeking Pieten Logic ---
        if (now - lastHallucinationCheck > 1500) { 
            lastHallucinationCheck = now;
            if (hallucinations.length < 3 && Math.random() < 0.4) {
                let spawnDist = 6 + Math.random() * 6;
                let hX = posX + dirX * spawnDist + (Math.random()-0.5)*4;
                let hY = posY + dirY * spawnDist + (Math.random()-0.5)*4;
                if (hX > 1 && hX < MAP_WIDTH-1 && hY > 1 && hY < MAP_HEIGHT-1) {
                    if (mapLayout[Math.floor(hY)][Math.floor(hX)] === 0) {
                        let piet = { x: hX, y: hY, type: 'piet', active: true, spawnTime: now };
                        hallucinations.push(piet);
                        sprites.push(piet);
                    }
                }
            }
        }
        
        for(let i = hallucinations.length - 1; i >= 0; i--) {
            let p = hallucinations[i];
            let distToPiet = Math.hypot(posX - p.x, posY - p.y);
            if (distToPiet < 4) {
                p.active = false; 
                hallucinations.splice(i, 1);
                playAmbientSound('vanish');
                let spriteIndex = sprites.indexOf(p);
                if (spriteIndex > -1) sprites.splice(spriteIndex, 1);
            }
        }

        // --- Sint AI ---
        let timeAlive = (now - startTime) / 1000;
        let sintSpeed = 0.035 + (timeAlive * 0.0004);
        if(sintSpeed > 0.09) sintSpeed = 0.09;

        let dx = posX - sint.x;
        let dy = posY - sint.y;
        let dist = Math.sqrt(dx*dx + dy*dy);
        
        if (dist > 0.5) {
            let sx = dx / dist * sintSpeed;
            let sy = dy / dist * sintSpeed;
            if (!isBlocking(mapLayout[Math.floor(sint.y)][Math.floor(sint.x + sx * 1.5)])) sint.x += sx;
            if (!isBlocking(mapLayout[Math.floor(sint.y + sy * 1.5)][Math.floor(sint.x)])) sint.y += sy;
        }

        sintProximity = Math.max(0, 1 - (dist / 12)); 
        updateSound(now);

        if (dist < 0.4) endGame(false);
        sprites.forEach(s => {
            if (!s.active || s.type !== 'door') return;
            let d = Math.sqrt((posX - s.x)**2 + (posY - s.y)**2);
            if (d < 0.6) endGame(true);
        });
    }

    // --- Audio ---
    function initAudio() {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if(audioCtx.state === 'suspended') audioCtx.resume();
    }

    function updateSound(now) {
        if(!audioCtx) return;
        if (now > nextAmbientSoundTime) {
            playAmbientSound('random');
            nextAmbientSoundTime = now + 3000 + Math.random() * 5000;
        }
    }

    function playAmbientSound(type) {
        if(!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        
        if (type === 'vanish') {
            const bufferSize = audioCtx.sampleRate * 0.5;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;
            const noiseGain = audioCtx.createGain();
            noise.connect(noiseGain);
            noiseGain.connect(audioCtx.destination);
            noiseGain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            noiseGain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);
            noise.start();
        } else if (Math.random() < 0.3) {
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(200, audioCtx.currentTime);
            osc.frequency.linearRampToValueAtTime(150, audioCtx.currentTime + 1);
            gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
            gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 1);
            osc.start();
            osc.stop(audioCtx.currentTime + 1);
        } else {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(50, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(10, audioCtx.currentTime + 1);
            gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
            gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 1);
            osc.start();
            osc.stop(audioCtx.currentTime + 1);
        }
    }

    function playScream() {
        if(!audioCtx) return;
        const bufferSize = audioCtx.sampleRate * 1.0;
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
        const noise = audioCtx.createBufferSource();
        noise.buffer = buffer;
        const gain = audioCtx.createGain();
        const filter = audioCtx.createBiquadFilter();
        filter.type = 'highpass';
        filter.frequency.value = 1000;
        noise.connect(filter);
        filter.connect(gain);
        gain.connect(audioCtx.destination);
        gain.gain.setValueAtTime(0.8, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 1.0);
        noise.start();
    }

    // --- Render ---
    function draw() {
        ctx.fillStyle = '#050505'; ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT / 2);
        ctx.fillStyle = '#111'; ctx.fillRect(0, SCREEN_HEIGHT / 2, SCREEN_WIDTH, SCREEN_HEIGHT / 2);

        let breathe = Math.sin(frameCount * 0.05) * 0.05;
        zBuffer = []; 

        for (let x = 0; x < SCREEN_WIDTH; x++) {
            let cameraX = 2 * x / SCREEN_WIDTH - 1;
            let rayDirX = dirX + planeX * cameraX;
            let rayDirY = dirY + planeY * cameraX;

            let mapX = Math.floor(posX);
            let mapY = Math.floor(posY);
            let sideDistX, sideDistY, perpWallDist;
            let stepX, stepY, side, wallType = 1;
            let deltaDistX = Math.abs(1 / rayDirX);
            let deltaDistY = Math.abs(1 / rayDirY);
            let hit = 0;

            if (rayDirX < 0) { stepX = -1; sideDistX = (posX - mapX) * deltaDistX; }
            else { stepX = 1; sideDistX = (mapX + 1.0 - posX) * deltaDistX; }
            if (rayDirY < 0) { stepY = -1; sideDistY = (posY - mapY) * deltaDistY; }
            else { stepY = 1; sideDistY = (mapY + 1.0 - posY) * deltaDistY; }

            while (hit === 0) {
                if (sideDistX < sideDistY) { sideDistX += deltaDistX; mapX += stepX; side = 0; }
                else { sideDistY += deltaDistY; mapY += stepY; side = 1; }
                let tile = mapLayout[mapY][mapX];
                if (tile === 1 || (tile >= 5 && tile <= 7)) { hit = 1; wallType = tile; }
            }

            if (side === 0) perpWallDist = (mapX - posX + (1 - stepX) / 2) / rayDirX;
            else            perpWallDist = (mapY - posY + (1 - stepY) / 2) / rayDirY;

            zBuffer[x] = perpWallDist; 

            let lineHeight = Math.floor(SCREEN_HEIGHT / perpWallDist);
            lineHeight *= (1 + breathe * (perpWallDist < 5 ? 1 : 0));
            
            let drawStart = -lineHeight / 2 + SCREEN_HEIGHT / 2;
            let drawEnd = lineHeight / 2 + SCREEN_HEIGHT / 2;

            let wallX; 
            if (side == 0) wallX = posY + perpWallDist * rayDirY;
            else           wallX = posX + perpWallDist * rayDirX;
            wallX -= Math.floor(wallX);
            let texX = Math.floor(wallX * texWidth);
            if(side == 0 && rayDirX > 0) texX = texWidth - texX - 1;
            if(side == 1 && rayDirY < 0) texX = texWidth - texX - 1;

            let tex = textures.wall;
            if(wallType === 5) tex = textures.wall_bloody_1;
            if(wallType === 6) tex = textures.wall_bloody_2;
            if(wallType === 7) tex = textures.wall_bloody_3;

            ctx.drawImage(tex, texX, 0, 1, texHeight, x, drawStart, 1, drawEnd - drawStart);
            
            let brightness = 1.0 / (perpWallDist * 0.5); 
            if (brightness > 1) brightness = 1;
            if (side === 1) brightness *= 0.6;
            ctx.fillStyle = `rgba(0,0,0,${1 - brightness})`;
            ctx.fillRect(x, drawStart, 1, drawEnd - drawStart);
        }

        sprites.forEach(s => {
            s.dist = ((posX - s.x) ** 2 + (posY - s.y) ** 2);
        });
        sprites.sort((a, b) => b.dist - a.dist);

        for (let i = 0; i < sprites.length; i++) {
            if(!sprites[i].active) continue;
            let sprite = sprites[i];
            let spriteX = sprite.x - posX;
            let spriteY = sprite.y - posY;

            let invDet = 1.0 / (planeX * dirY - dirX * planeY);
            let transformX = invDet * (dirY * spriteX - dirX * spriteY);
            let transformY = invDet * (-planeY * spriteX + planeX * spriteY); 
            let spriteScreenX = Math.floor((SCREEN_WIDTH / 2) * (1 + transformX / transformY));
            let spriteHeight = Math.abs(Math.floor(SCREEN_HEIGHT / transformY));
            
            let animOffset = 0;
            if (sprite.type === 'piet') animOffset = Math.sin(frameCount * 0.05) * 10;
            // Paper floats slightly
            if (sprite.type === 'paper') animOffset = Math.sin(frameCount * 0.1) * 5 + 60; // Lower on screen

            let drawStartY = -spriteHeight / 2 + SCREEN_HEIGHT / 2 + animOffset / transformY;
            let drawEndY = spriteHeight / 2 + SCREEN_HEIGHT / 2 + animOffset / transformY;
            let spriteWidth = Math.abs(Math.floor(SCREEN_HEIGHT / transformY));
            let drawStartX = -spriteWidth / 2 + spriteScreenX;
            let drawEndX = spriteWidth / 2 + spriteScreenX;

            let tex;
            if (sprite.type === 'door') tex = textures.door;
            else if (sprite.type === 'sint') tex = textures.sint;
            else if (sprite.type === 'piet') tex = textures.piet;
            else if (sprite.type === 'paper') tex = textures.paper;

            if (sprite.type === 'piet') ctx.globalAlpha = 0.8; 
            else ctx.globalAlpha = 1.0;

            for (let stripe = Math.floor(drawStartX); stripe < Math.floor(drawEndX); stripe++) {
                let texX = Math.floor(256 * (stripe - (-spriteWidth / 2 + spriteScreenX)) * 64 / spriteWidth) / 256;
                let realTexX = Math.floor((stripe - (-spriteWidth / 2 + spriteScreenX)) * 128 / spriteWidth);
                
                if (transformY > 0 && stripe > 0 && stripe < SCREEN_WIDTH && transformY < zBuffer[stripe]) {
                    ctx.drawImage(tex, realTexX, 0, 1, 128, stripe, drawStartY, 1, drawEndY - drawStartY);
                    let brightness = 1.0 / (transformY * 0.5);
                    if (brightness > 1) brightness = 1;
                    if (brightness < 0) brightness = 0;
                    
                    // Paper glows in dark
                    if (sprite.type !== 'paper') {
                        ctx.fillStyle = `rgba(0,0,0,${1 - brightness})`;
                        ctx.fillRect(stripe, drawStartY, 1, drawEndY - drawStartY);
                    }
                }
            }
            ctx.globalAlpha = 1.0;
        }
    }

    function gameLoop() {
        if(!gameRunning) return;
        updateGame();
        draw();
        requestAnimationFrame(gameLoop);
    }

    function endGame(win) {
        gameRunning = false;
        if(!win) {
            playScream();
            jumpscareOverlay.style.opacity = 1;
            let flashCount = 0;
            let flashInt = setInterval(() => {
                jumpscareOverlay.style.filter = `invert(${Math.random() > 0.5 ? 1 : 0}) contrast(2)`;
                jumpscareOverlay.style.transform = `scale(${1 + Math.random()*0.1})`;
                flashCount++;
                if(flashCount > 20) clearInterval(flashInt);
            }, 50);
            setTimeout(() => { showMenu(win); }, 3000);
        } else {
            showMenu(win);
        }
    }

    function showMenu(win) {
        let title = win ? "ONTSNAPT" : "DOOD";
        msgOverlay.querySelector('h1').innerText = title;
        msgOverlay.querySelector('h1').style.color = win ? "#4a4" : "#900";
        msgOverlay.querySelector('p').innerText = win ? "Je bent vrij." : "Geen genade.";
        msgOverlay.querySelectorAll('p')[1].innerText = "";
        startBtn.innerText = "OPNIEUW";
        msgOverlay.classList.remove('hidden');
        jumpscareOverlay.style.opacity = 0;
    }
</script>
</body>
</html>
