<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>De Wraak van de Sint - 3D Horror</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Creepster&family=Nosifer&family=Roboto:wght@400;700&display=swap');

        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            color: #d00;
            font-family: 'Roboto', sans-serif;
            overflow: hidden;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Retro pixelated look */
        canvas {
            image-rendering: pixelated; 
            width: 100%;
            height: 100%;
            max-width: 100%;
            max-height: 100%;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        #score-display {
            color: #e6b800; /* Gold */
            font-family: 'Creepster', cursive;
            font-size: 3rem;
            text-shadow: 2px 2px 0 #000, 0 0 10px #ff0000;
        }

        #stamina-bar-container {
            width: 300px;
            height: 25px;
            background: #222;
            border: 3px solid #500;
            align-self: flex-start;
            margin-top: 10px;
            box-shadow: 0 0 10px #000;
        }

        #stamina-bar {
            width: 100%;
            height: 100%;
            background: #00cc00;
            transition: width 0.1s;
        }

        #message-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            pointer-events: auto;
            text-align: center;
        }

        h1 {
            font-family: 'Nosifer', cursive;
            font-size: 4rem;
            color: #ff0000;
            margin-bottom: 20px;
            animation: pulse 2s infinite;
            text-shadow: 0 5px 10px #000;
        }

        p {
            color: #ccc;
            font-size: 1.2rem;
            max-width: 600px;
            margin: 0 auto 30px auto;
            line-height: 1.5;
            text-shadow: 1px 1px 2px #000;
        }

        button {
            background: #500;
            color: #fff;
            border: 2px solid #f00;
            padding: 20px 40px;
            font-size: 2rem;
            font-family: 'Creepster', cursive;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
        }

        button:hover {
            background: #f00;
            box-shadow: 0 0 30px #f00;
            transform: scale(1.05);
        }

        .hidden {
            display: none !important;
        }

        /* Blood overlay vignette */
        #vignette {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, transparent 50%, rgba(0,0,0,0.8) 90%, black 100%);
            pointer-events: none;
            z-index: 10;
        }

        #damage-flash {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: red;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s;
            z-index: 11;
        }

        @keyframes pulse {
            0% { text-shadow: 0 0 10px #500; }
            50% { text-shadow: 0 0 25px #f00; transform: scale(1.02); }
            100% { text-shadow: 0 0 10px #500; }
        }

        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            20% { transform: translate(-3px, 0px) rotate(1deg); }
            40% { transform: translate(1px, -1px) rotate(1deg); }
            60% { transform: translate(-3px, 1px) rotate(0deg); }
            80% { transform: translate(-1px, -1px) rotate(1deg); }
            100% { transform: translate(1px, -2px) rotate(-1deg); }
        }

        .shaking {
            animation: shake 0.5s;
            animation-iteration-count: infinite;
        }
        
        #controls-hint {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            color: #888;
            font-family: 'Creepster', cursive;
            font-size: 1.2rem;
            text-shadow: 1px 1px 0 #000;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <div id="vignette"></div>
    <div id="damage-flash"></div>
    
    <div id="ui-layer">
        <div>
            <div id="score-display">Wortels: 0 / 3</div>
            <div id="stamina-bar-container"><div id="stamina-bar"></div></div>
        </div>
        <div id="controls-hint" class="hidden">W/S: Lopen | A/D: Draaien | SHIFT: Rennen</div>
    </div>

    <div id="message-overlay">
        <h1>ONTSNAP AAN DE SINT</h1>
        <p>DOOM EDITIE</p>
        <p>Je zit gevangen in een 3D doolhof. Vind de <strong>3 Gouden Wortels</strong>. De Sint is hier. Hij kijkt. Hij wacht.</p>
        <button id="start-btn">START</button>
    </div>
</div>

<script>
    // --- Configuration (Doom Style) ---
    const MAP_WIDTH = 25;
    const MAP_HEIGHT = 18;
    const SCREEN_WIDTH = 640;  // Internal resolution for retro feel
    const SCREEN_HEIGHT = 360;
    const FOV = 0.66; // Field of view (approx 66 degrees)
    
    // Speeds
    const MOVE_SPEED = 0.08;
    const RUN_SPEED = 0.14;
    const ROT_SPEED = 0.06;
    
    // --- Audio ---
    let audioCtx;
    let droneOsc;
    
    // --- Game State ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d', { alpha: false }); // Optimize
    const uiLayer = document.getElementById('ui-layer');
    const msgOverlay = document.getElementById('message-overlay');
    const startBtn = document.getElementById('start-btn');
    const scoreDisplay = document.getElementById('score-display');
    const staminaBar = document.getElementById('stamina-bar');
    const controlsHint = document.getElementById('controls-hint');
    const gameContainer = document.getElementById('game-container');
    const damageFlash = document.getElementById('damage-flash');

    let gameRunning = false;
    let keys = {};
    let carrotsCollected = 0;
    let stamina = 100;
    let sintProximity = 0;
    let zBuffer = []; // For sprite depth checking

    // Map: 0=Floor, 1=Wall, 2=Start, 3=Exit, 4=Carrot
    // Same layout, processed into a grid
    const mapLayout = [
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
        [1,2,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,1,1,1,0,1,0,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1],
        [1,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,1],
        [1,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,1,1],
        [1,0,0,0,1,4,0,0,0,0,0,0,0,0,0,0,1,4,1,0,0,0,0,0,1],
        [1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,0,1],
        [1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,1,1,1,1,0,1,1,0,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1],
        [1,0,0,0,0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1],
        [1,1,1,1,0,1,0,1,0,1,1,1,1,0,1,1,0,1,1,1,1,0,1,1,1],
        [1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,4,0,1,0,0,0,1],
        [1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,1,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1],
        [1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,1],
        [1,3,1,0,0,0,1,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,1,1,1],
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
    ];

    // Player (camera)
    let posX = 0, posY = 0; // Position vector
    let dirX = -1, dirY = 0; // Direction vector
    let planeX = 0, planeY = 0.66; // Camera plane (determines FOV)

    // Entities
    let sint = { x: 0, y: 0, active: true };
    let sprites = []; // Will hold carrots + sint + exit
    
    // Textures (Generated via code)
    const texWidth = 64;
    const texHeight = 64;
    let textures = {}; // Will hold Images/Canvases

    // --- Texture Generation ---
    function generateTextures() {
        function createTexture(color1, color2, type) {
            const c = document.createElement('canvas');
            c.width = texWidth; c.height = texHeight;
            const cx = c.getContext('2d');
            
            // Background
            cx.fillStyle = color1;
            cx.fillRect(0,0,64,64);

            if (type === 'wall') {
                // Bricks
                cx.fillStyle = color2;
                for(let i=0; i<100; i++) cx.fillRect(Math.random()*64, Math.random()*64, 2, 2); // Noise
                cx.fillStyle = 'rgba(0,0,0,0.3)';
                cx.fillRect(0, 0, 64, 2); // Top mortar
                cx.fillRect(0, 32, 64, 2); // Mid mortar
                cx.fillRect(0, 0, 2, 32); 
                cx.fillRect(32, 32, 2, 32); 
            } else if (type === 'exit') {
                cx.fillStyle = '#0f0';
                cx.font = '30px Arial';
                cx.fillText("UIT", 5, 40);
                cx.strokeStyle = '#fff';
                cx.lineWidth = 4;
                cx.strokeRect(2,2,60,60);
            }
            return c;
        }

        function createSprite(type) {
            const c = document.createElement('canvas');
            c.width = 64; c.height = 64;
            const cx = c.getContext('2d');
            
            if (type === 'carrot') {
                cx.fillStyle = 'orange';
                cx.beginPath(); cx.moveTo(32, 60); cx.lineTo(15, 15); cx.lineTo(49, 15); cx.fill();
                cx.fillStyle = '#0f0'; // Leaf
                cx.fillRect(28, 0, 8, 15);
                // Gold Glow
                cx.strokeStyle = 'yellow'; cx.lineWidth=2; cx.stroke();
            } else if (type === 'sint') {
                // Mitre
                cx.fillStyle = '#900';
                cx.beginPath(); cx.moveTo(10, 30); cx.lineTo(32, 5); cx.lineTo(54, 30); cx.lineTo(54, 60); cx.lineTo(10, 60); cx.fill();
                // Cross
                cx.fillStyle = '#eb0'; cx.fillRect(28, 15, 8, 30); cx.fillRect(18, 25, 28, 8);
                // Glowing Eyes
                cx.fillStyle = '#fff'; 
                cx.beginPath(); cx.arc(24, 45, 3, 0, Math.PI*2); cx.arc(40, 45, 3, 0, Math.PI*2); cx.fill();
                cx.fillStyle = '#f00'; 
                cx.beginPath(); cx.arc(24, 45, 1, 0, Math.PI*2); cx.arc(40, 45, 1, 0, Math.PI*2); cx.fill();
            }
            return c;
        }

        textures.wall = createTexture('#444', '#555', 'wall'); // Grey brick
        textures.exit = createTexture('#050', '#0a0', 'exit');
        textures.carrot = createSprite('carrot');
        textures.sint = createSprite('sint');
    }

    // --- Initialization ---

    function initGame() {
        canvas.width = SCREEN_WIDTH;
        canvas.height = SCREEN_HEIGHT;
        generateTextures();
        
        sprites = [];
        
        // Parse Map
        for(let y=0; y<MAP_HEIGHT; y++) {
            for(let x=0; x<MAP_WIDTH; x++) {
                let type = mapLayout[y][x];
                if(type === 2) { // Start
                    posX = x + 0.5;
                    posY = y + 0.5;
                    // Initial dir
                    dirX = 1; dirY = 0;
                    planeX = 0; planeY = 0.66;
                } else if(type === 4) { // Carrot
                    sprites.push({ x: x+0.5, y: y+0.5, type: 'carrot', active: true });
                } else if(type === 3) {
                    sprites.push({ x: x+0.5, y: y+0.5, type: 'exit', active: true });
                }
            }
        }

        // Setup Sint
        sint = { x: MAP_WIDTH - 2.5, y: MAP_HEIGHT - 2.5, type: 'sint', active: true };
        sprites.push(sint);
        
        carrotsCollected = 0;
        stamina = 100;
        gameRunning = true;
        
        scoreDisplay.innerText = "Wortels: 0 / 3";
        msgOverlay.classList.add('hidden');
        controlsHint.classList.remove('hidden');
        damageFlash.style.opacity = 0;
        
        initAudio();
        requestAnimationFrame(gameLoop);
    }

    // --- Input Handling ---

    window.addEventListener('keydown', (e) => {
        keys[e.key.toLowerCase()] = true;
        if(e.shiftKey) keys['shift'] = true;
    });

    window.addEventListener('keyup', (e) => {
        keys[e.key.toLowerCase()] = false;
        if(!e.shiftKey) keys['shift'] = false;
    });

    startBtn.addEventListener('click', () => {
        initGame();
    });

    // --- Physics & Logic ---

    function updateGame() {
        // Movement Logic (Doom Tank Controls)
        // Rotate
        if (keys['d'] || keys['arrowright']) {
            // Rotated Right (Clockwise) -> Positive Angle
            let oldDirX = dirX;
            dirX = dirX * Math.cos(ROT_SPEED) - dirY * Math.sin(ROT_SPEED);
            dirY = oldDirX * Math.sin(ROT_SPEED) + dirY * Math.cos(ROT_SPEED);
            let oldPlaneX = planeX;
            planeX = planeX * Math.cos(ROT_SPEED) - planeY * Math.sin(ROT_SPEED);
            planeY = oldPlaneX * Math.sin(ROT_SPEED) + planeY * Math.cos(ROT_SPEED);
        }
        if (keys['a'] || keys['arrowleft']) {
            // Rotate Left (Counter-Clockwise) -> Negative Angle
            let oldDirX = dirX;
            dirX = dirX * Math.cos(-ROT_SPEED) - dirY * Math.sin(-ROT_SPEED);
            dirY = oldDirX * Math.sin(-ROT_SPEED) + dirY * Math.cos(-ROT_SPEED);
            let oldPlaneX = planeX;
            planeX = planeX * Math.cos(-ROT_SPEED) - planeY * Math.sin(-ROT_SPEED);
            planeY = oldPlaneX * Math.sin(-ROT_SPEED) + planeY * Math.cos(-ROT_SPEED);
        }

        // Move
        let currentSpeed = MOVE_SPEED;
        if (keys['shift'] && stamina > 0) {
            currentSpeed = RUN_SPEED;
            stamina -= 1;
        } else {
            stamina = Math.min(100, stamina + 0.5);
        }
        staminaBar.style.width = stamina + "%";
        staminaBar.style.background = stamina < 20 ? "#f00" : "#00cc00";

        // Check !== 1 (Wall) instead of === 0 (Floor) to allow walking on Start(2), Exit(3), Carrots(4)
        if (keys['w'] || keys['arrowup']) {
            if(mapLayout[Math.floor(posY)][Math.floor(posX + dirX * currentSpeed * 2)] !== 1) posX += dirX * currentSpeed;
            if(mapLayout[Math.floor(posY + dirY * currentSpeed * 2)][Math.floor(posX)] !== 1) posY += dirY * currentSpeed;
        }
        if (keys['s'] || keys['arrowdown']) {
            if(mapLayout[Math.floor(posY)][Math.floor(posX - dirX * currentSpeed * 2)] !== 1) posX -= dirX * currentSpeed;
            if(mapLayout[Math.floor(posY - dirY * currentSpeed * 2)][Math.floor(posX)] !== 1) posY -= dirY * currentSpeed;
        }

        // Sint AI (Simple Chase)
        // 0.03 speed is fairly fast for an enemy in this grid
        let sintSpeed = 0.025; 
        if (carrotsCollected === 3) sintSpeed = 0.045; // Enrage

        // Simple BFS or direct line? Direct line with simple wall slide
        let dx = posX - sint.x;
        let dy = posY - sint.y;
        let dist = Math.sqrt(dx*dx + dy*dy);
        
        if (dist > 0.5) {
            let sx = dx / dist * sintSpeed;
            let sy = dy / dist * sintSpeed;
            
            // Basic collision for Sint
            if (mapLayout[Math.floor(sint.y)][Math.floor(sint.x + sx * 1.5)] === 0) sint.x += sx;
            if (mapLayout[Math.floor(sint.y + sy * 1.5)][Math.floor(sint.x)] === 0) sint.y += sy;
        }

        // Audio Proximity
        sintProximity = Math.max(0, 1 - (dist / 10)); // 10 blocks range
        updateSound();

        // Death
        if (dist < 0.5) {
            endGame(false);
        }

        // Item Pickup
        sprites.forEach(s => {
            if (!s.active) return;
            let d = Math.sqrt((posX - s.x)**2 + (posY - s.y)**2);
            if (d < 0.5) {
                if (s.type === 'carrot') {
                    s.active = false;
                    carrotsCollected++;
                    scoreDisplay.innerText = `Wortels: ${carrotsCollected} / 3`;
                    playSound('pickup');
                    if(carrotsCollected === 3) {
                        scoreDisplay.innerText = "VIND DE UITGANG!";
                        scoreDisplay.style.color = "#fff";
                    }
                } else if (s.type === 'exit' && carrotsCollected >= 3) {
                    endGame(true);
                }
            }
        });
    }

    // --- Audio System ---
    
    function initAudio() {
        if (!audioCtx) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if(audioCtx.state === 'suspended') audioCtx.resume();

        // Background Drone
        if(!droneOsc) {
            droneOsc = audioCtx.createOscillator();
            let gain = audioCtx.createGain();
            droneOsc.type = 'sawtooth';
            droneOsc.frequency.value = 40;
            droneOsc.connect(gain);
            gain.connect(audioCtx.destination);
            gain.gain.value = 0.05;
            droneOsc.start();
            droneOsc.gainNode = gain;
        }
    }

    function updateSound() {
        if(!droneOsc) return;
        
        // Pitch rises as Sint gets closer
        droneOsc.frequency.value = 40 + (sintProximity * 80);
        let vol = 0.05 + (sintProximity * 0.1);
        droneOsc.gainNode.gain.value = vol;

        if(sintProximity > 0.6) {
            gameContainer.classList.add('shaking');
        } else {
            gameContainer.classList.remove('shaking');
        }
    }

    function playSound(type) {
        if(!audioCtx) return;
        let osc = audioCtx.createOscillator();
        let gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);

        if(type === 'pickup') {
            osc.type = 'square';
            osc.frequency.setValueAtTime(600, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(1200, audioCtx.currentTime + 0.1);
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.2);
        } else if (type === 'scream') {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(200, audioCtx.currentTime);
            osc.frequency.linearRampToValueAtTime(50, audioCtx.currentTime + 1);
            gain.gain.value = 0.5;
            osc.start();
            osc.stop(audioCtx.currentTime + 1);
        }
    }

    // --- Raycasting Engine ---

    function draw() {
        // Floor & Ceiling (Simple fill)
        ctx.fillStyle = '#111'; // Ceiling
        ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT / 2);
        ctx.fillStyle = '#1a1a1a'; // Floor
        ctx.fillRect(0, SCREEN_HEIGHT / 2, SCREEN_WIDTH, SCREEN_HEIGHT / 2);

        // Raycasting Walls
        zBuffer = []; // Clear Z Buffer

        for (let x = 0; x < SCREEN_WIDTH; x++) {
            let cameraX = 2 * x / SCREEN_WIDTH - 1;
            let rayDirX = dirX + planeX * cameraX;
            let rayDirY = dirY + planeY * cameraX;

            let mapX = Math.floor(posX);
            let mapY = Math.floor(posY);

            let sideDistX, sideDistY;
            let deltaDistX = Math.abs(1 / rayDirX);
            let deltaDistY = Math.abs(1 / rayDirY);
            let perpWallDist;

            let stepX, stepY;
            let hit = 0;
            let side; // 0 for NS, 1 for EW

            if (rayDirX < 0) {
                stepX = -1;
                sideDistX = (posX - mapX) * deltaDistX;
            } else {
                stepX = 1;
                sideDistX = (mapX + 1.0 - posX) * deltaDistX;
            }
            if (rayDirY < 0) {
                stepY = -1;
                sideDistY = (posY - mapY) * deltaDistY;
            } else {
                stepY = 1;
                sideDistY = (mapY + 1.0 - posY) * deltaDistY;
            }

            // DDA
            while (hit === 0) {
                if (sideDistX < sideDistY) {
                    sideDistX += deltaDistX;
                    mapX += stepX;
                    side = 0;
                } else {
                    sideDistY += deltaDistY;
                    mapY += stepY;
                    side = 1;
                }
                if (mapLayout[mapY][mapX] > 0 && mapLayout[mapY][mapX] !== 2 && mapLayout[mapY][mapX] !== 4 && mapLayout[mapY][mapX] !== 3) {
                     // Check if it's a wall (1)
                     if (mapLayout[mapY][mapX] === 1) hit = 1;
                }
            }

            if (side === 0) perpWallDist = (mapX - posX + (1 - stepX) / 2) / rayDirX;
            else            perpWallDist = (mapY - posY + (1 - stepY) / 2) / rayDirY;

            zBuffer[x] = perpWallDist; // Store for sprites

            // Calculate height of line to draw
            let lineHeight = Math.floor(SCREEN_HEIGHT / perpWallDist);
            let drawStart = -lineHeight / 2 + SCREEN_HEIGHT / 2;
            if (drawStart < 0) drawStart = 0;
            let drawEnd = lineHeight / 2 + SCREEN_HEIGHT / 2;
            if (drawEnd >= SCREEN_HEIGHT) drawEnd = SCREEN_HEIGHT - 1;

            // Texture calculations
            let wallX; 
            if (side == 0) wallX = posY + perpWallDist * rayDirY;
            else           wallX = posX + perpWallDist * rayDirX;
            wallX -= Math.floor(wallX);

            let texX = Math.floor(wallX * texWidth);
            if(side == 0 && rayDirX > 0) texX = texWidth - texX - 1;
            if(side == 1 && rayDirY < 0) texX = texWidth - texX - 1;

            // Shading (Darkness)
            let brightness = 1.0 / (perpWallDist * 0.5); 
            if (brightness > 1) brightness = 1;
            // darker on y-sides
            if (side === 1) brightness *= 0.7;

            // Draw Wall Strip
            // We use drawImage to draw a 1px slice of the texture
            ctx.globalAlpha = 1.0; // Reset alpha
            ctx.drawImage(textures.wall, texX, 0, 1, texHeight, x, drawStart, 1, drawEnd - drawStart);
            
            // Apply darkness overlay
            ctx.fillStyle = `rgba(0,0,0,${1 - brightness})`;
            ctx.fillRect(x, drawStart, 1, drawEnd - drawStart);
        }

        // --- Sprite Casting ---
        // Sort sprites from far to close
        sprites.forEach(sprite => {
            sprite.dist = ((posX - sprite.x) * (posX - sprite.x) + (posY - sprite.y) * (posY - sprite.y));
        });
        sprites.sort((a, b) => b.dist - a.dist);

        for (let i = 0; i < sprites.length; i++) {
            if(!sprites[i].active) continue;

            let sprite = sprites[i];
            let spriteX = sprite.x - posX;
            let spriteY = sprite.y - posY;

            // Transform sprite with the inverse camera matrix
            let invDet = 1.0 / (planeX * dirY - dirX * planeY);
            let transformX = invDet * (dirY * spriteX - dirX * spriteY);
            let transformY = invDet * (-planeY * spriteX + planeX * spriteY); // this is depth inside the screen

            let spriteScreenX = Math.floor((SCREEN_WIDTH / 2) * (1 + transformX / transformY));

            // Calculate height of the sprite on screen
            let spriteHeight = Math.abs(Math.floor(SCREEN_HEIGHT / transformY));
            let drawStartY = -spriteHeight / 2 + SCREEN_HEIGHT / 2;
            if (drawStartY < 0) drawStartY = 0;
            let drawEndY = spriteHeight / 2 + SCREEN_HEIGHT / 2;
            if (drawEndY >= SCREEN_HEIGHT) drawEndY = SCREEN_HEIGHT - 1;

            // Calculate width of the sprite
            let spriteWidth = Math.abs(Math.floor(SCREEN_HEIGHT / transformY));
            let drawStartX = -spriteWidth / 2 + spriteScreenX;
            let drawEndX = spriteWidth / 2 + spriteScreenX;
            if (drawStartX < 0) drawStartX = 0;
            if (drawEndX >= SCREEN_WIDTH) drawEndX = SCREEN_WIDTH - 1;

            // Draw Sprite strip by strip
            let tex = (sprite.type === 'carrot') ? textures.carrot : 
                      (sprite.type === 'exit') ? textures.exit : textures.sint;

            for (let stripe = Math.floor(drawStartX); stripe < Math.floor(drawEndX); stripe++) {
                let texX = Math.floor(256 * (stripe - (-spriteWidth / 2 + spriteScreenX)) * texWidth / spriteWidth) / 256;
                
                // Only draw if:
                // 1. It's in front of camera plane (transformY > 0)
                // 2. It's on the screen
                // 3. It's closer than the wall at this column (Z-Buffer check)
                if (transformY > 0 && stripe > 0 && stripe < SCREEN_WIDTH && transformY < zBuffer[stripe]) {
                    ctx.drawImage(tex, texX, 0, 1, texHeight, stripe, drawStartY, 1, drawEndY - drawStartY);
                    
                    // Darken sprite with distance
                    let brightness = 1.0 / (transformY * 0.5);
                    if (brightness > 1) brightness = 1;
                    if (brightness < 0) brightness = 0;
                    ctx.fillStyle = `rgba(0,0,0,${1 - brightness})`;
                    ctx.fillRect(stripe, drawStartY, 1, drawEndY - drawStartY);
                }
            }
        }
    }

    function gameLoop() {
        if(!gameRunning) return;
        updateGame();
        draw();
        requestAnimationFrame(gameLoop);
    }

    function endGame(win) {
        gameRunning = false;
        gameContainer.classList.remove('shaking');
        
        let title = win ? "ONTSNAPT!" : "GEPAKT!";
        let desc = win 
            ? "Je hebt de uitgang gevonden. Het Sinterklaasfeest is gered... voor jou." 
            : "Sinterklaas heeft je gevonden. Volgend jaar ben jij Zwarte Piet.";
        let btnText = "OPNIEUW";
        let color = win ? "#0f0" : "#f00";

        if(!win) {
            playSound('scream');
            damageFlash.style.opacity = 1;
        }

        msgOverlay.querySelector('h1').innerText = title;
        msgOverlay.querySelector('h1').style.color = color;
        msgOverlay.querySelector('p').innerText = desc;
        msgOverlay.querySelectorAll('p')[1].innerText = "";
        startBtn.innerText = btnText;
        msgOverlay.classList.remove('hidden');
        controlsHint.classList.add('hidden');
        
        if(droneOsc) {
            droneOsc.stop();
            droneOsc = null;
        }
    }

</script>
</body>
</html>
